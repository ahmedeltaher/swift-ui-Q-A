<!DOCTYPE html>
<html lang="ar" dir="rtl">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>List Refresh in SwiftUI</title>
    
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-tomorrow.min.css" rel="stylesheet">
    
    <style>
      body {
        font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
        line-height: 1.6;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        direction: rtl;
      }
      .container {
        background: white;
        border-radius: 15px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        margin: 2rem auto;
        padding: 2rem;
        max-width: 1200px;
      }
      .question-title {
        color: #2c3e50;
        border-bottom: 3px solid #3498db;
        padding-bottom: 1rem;
        margin-bottom: 2rem;
        font-weight: 700;
      }
      .section-title {
        color: #e74c3c;
        margin: 2rem 0 1rem 0;
        font-weight: 600;
        font-size: 1.3rem;
      }
      .code-container {
        background: #2d3748;
        border-radius: 10px;
        padding: 1.5rem;
        margin: 1rem 0;
        overflow-x: auto;
      }
      .code-container code {
        color: #e2e8f0;
        font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
      }
      .highlight-box {
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
        padding: 1.5rem;
        border-radius: 10px;
        margin: 1.5rem 0;
      }
      .back-btn {
        background: linear-gradient(135deg, #667eea, #764ba2);
        border: none;
        color: white;
        padding: 0.7rem 1.5rem;
        border-radius: 25px;
        font-weight: 600;
        transition: transform 0.3s ease;
        text-decoration: none;
        display: inline-block;
        margin-bottom: 2rem;
      }
      .back-btn:hover {
        transform: translateY(-2px);
        color: white;
      }
      .concept-box {
        background: #f8f9fa;
        border-left: 4px solid #3498db;
        padding: 1rem 1.5rem;
        margin: 1rem 0;
        border-radius: 0 8px 8px 0;
      }
      .warning-box {
        background: #fff3cd;
        border-left: 4px solid #ffc107;
        padding: 1rem 1.5rem;
        margin: 1rem 0;
        border-radius: 0 8px 8px 0;
      }
      .success-box {
        background: #d1edff;
        border-left: 4px solid #17a2b8;
        padding: 1rem 1.5rem;
        margin: 1rem 0;
        border-radius: 0 8px 8px 0;
      }
    </style>
  </head>

  <body>
    <div class="container">
      <a href="../SwiftUI_Interview_Questions.html" class="back-btn">
        ← العودة للصفحة الرئيسية
      </a>

      <h1 class="question-title">
        How do you refresh a List in SwiftUI? (pull-to-refresh, task modifier)
      </h1>

      <div class="highlight-box">
        <h4>🔄 الفكرة الأساسية</h4>
        <p>
          <strong>List Refresh</strong> في SwiftUI بيتم بطرق مختلفة حسب iOS version والاستخدام المطلوب. 
          من Pull-to-Refresh المعتاد للـ Task modifier الجديد مع iOS 15+.
        </p>
      </div>

      <h2 class="section-title">📝 الشرح بالعربي</h2>
      <p>
        تحديث البيانات في List من أهم المميزات في أي تطبيق. SwiftUI بيوفر طرق مختلفة للـ refresh، 
        من الـ pull-to-refresh التقليدي للـ task modifier اللي بيشتغل مع async/await.
        كل طريقة لها استخداماتها المناسبة.
      </p>

      <h2 class="section-title">🎯 iOS 15+ Modern Approach: refreshable</h2>

      <div class="success-box">
        <h5>1. Built-in Pull-to-Refresh</h5>
        <p>الطريقة الأسهل والأحدث باستخدام refreshable modifier</p>
      </div>

      <div class="code-container">
        <pre><code class="language-swift">
struct ModernListView: View {
    @StateObject private var viewModel = DataViewModel()
    
    var body: some View {
        NavigationView {
            List(viewModel.items, id: \.id) { item in
                ItemRowView(item: item)
            }
            .refreshable {
                await viewModel.refreshData()
            }
            .navigationTitle("Items")
        }
    }
}

@MainActor
class DataViewModel: ObservableObject {
    @Published var items: [Item] = []
    @Published var isLoading = false
    
    func refreshData() async {
        isLoading = true
        
        do {
            // Simulate network call
            try await Task.sleep(nanoseconds: 1_000_000_000) // 1 second
            
            // Fetch new data
            let newItems = await APIService.shared.fetchItems()
            items = newItems
            
        } catch {
            print("Error refreshing data: \(error)")
        }
        
        isLoading = false
    }
    
    func loadInitialData() async {
        await refreshData()
    }
}
</code></pre>
      </div>

      <h2 class="section-title">⚡ Task Modifier for Initial Loading</h2>

      <div class="concept-box">
        <h5>استخدام Task modifier للتحميل الأولي</h5>
        <p>Task modifier بيسمح بتشغيل async operations عند ظهور الـ view</p>
      </div>

      <div class="code-container">
        <pre><code class="language-swift">
struct ItemListView: View {
    @StateObject private var viewModel = ItemViewModel()
    
    var body: some View {
        NavigationView {
            Group {
                if viewModel.items.isEmpty && viewModel.isLoading {
                    ProgressView("Loading...")
                } else {
                    List {
                        ForEach(viewModel.items) { item in
                            ItemRowView(item: item)
                        }
                    }
                    .refreshable {
                        await viewModel.refreshData()
                    }
                }
            }
            .navigationTitle("Items")
            .task {
                // This runs when view appears and automatically cancels when view disappears
                await viewModel.loadInitialData()
            }
        }
    }
}

struct ItemRowView: View {
    let item: Item
    
    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            Text(item.title)
                .font(.headline)
            Text(item.subtitle)
                .font(.caption)
                .foregroundColor(.secondary)
        }
        .padding(.vertical, 2)
    }
}
</code></pre>
      </div>

      <h2 class="section-title">🔄 Custom Pull-to-Refresh (Pre-iOS 15)</h2>

      <div class="warning-box">
        <h5>للمشاريع اللي بتدعم iOS 14 وأقل</h5>
        <p>تطبيق custom pull-to-refresh باستخدام UIViewRepresentable</p>
      </div>

      <div class="code-container">
        <pre><code class="language-swift">
struct RefreshableScrollView<Content: View>: UIViewRepresentable {
    let content: Content
    let onRefresh: () async -> Void
    
    init(@ViewBuilder content: () -> Content, onRefresh: @escaping () async -> Void) {
        self.content = content()
        self.onRefresh = onRefresh
    }
    
    func makeUIView(context: Context) -> UIScrollView {
        let scrollView = UIScrollView()
        let refreshControl = UIRefreshControl()
        
        refreshControl.addTarget(
            context.coordinator,
            action: #selector(Coordinator.handleRefresh),
            for: .valueChanged
        )
        
        scrollView.refreshControl = refreshControl
        
        let hostingController = UIHostingController(rootView: content)
        hostingController.view.translatesAutoresizingMaskIntoConstraints = false
        
        scrollView.addSubview(hostingController.view)
        
        NSLayoutConstraint.activate([
            hostingController.view.leadingAnchor.constraint(equalTo: scrollView.leadingAnchor),
            hostingController.view.trailingAnchor.constraint(equalTo: scrollView.trailingAnchor),
            hostingController.view.topAnchor.constraint(equalTo: scrollView.topAnchor),
            hostingController.view.bottomAnchor.constraint(equalTo: scrollView.bottomAnchor),
            hostingController.view.widthAnchor.constraint(equalTo: scrollView.widthAnchor)
        ])
        
        context.coordinator.refreshControl = refreshControl
        
        return scrollView
    }
    
    func updateUIView(_ uiView: UIScrollView, context: Context) {
        // Update if needed
    }
    
    func makeCoordinator() -> Coordinator {
        Coordinator(onRefresh: onRefresh)
    }
    
    class Coordinator: NSObject {
        let onRefresh: () async -> Void
        var refreshControl: UIRefreshControl?
        
        init(onRefresh: @escaping () async -> Void) {
            self.onRefresh = onRefresh
        }
        
        @objc func handleRefresh() {
            Task {
                await onRefresh()
                await MainActor.run {
                    refreshControl?.endRefreshing()
                }
            }
        }
    }
}

// Usage
struct LegacyListView: View {
    @StateObject private var viewModel = DataViewModel()
    
    var body: some View {
        RefreshableScrollView(
            content: {
                LazyVStack {
                    ForEach(viewModel.items) { item in
                        ItemRowView(item: item)
                    }
                }
            },
            onRefresh: {
                await viewModel.refreshData()
            }
        )
    }
}
</code></pre>
      </div>

      <h2 class="section-title">🎛️ Advanced Refresh Patterns</h2>

      <div class="success-box">
        <h5>1. Multiple Data Sources</h5>
        <p>تحديث عدة مصادر بيانات في نفس الوقت</p>
      </div>

      <div class="code-container">
        <pre><code class="language-swift">
@MainActor
class MultiSourceViewModel: ObservableObject {
    @Published var users: [User] = []
    @Published var posts: [Post] = []
    @Published var notifications: [Notification] = []
    @Published var isRefreshing = false
    
    func refreshAll() async {
        isRefreshing = true
        
        async let usersTask = APIService.shared.fetchUsers()
        async let postsTask = APIService.shared.fetchPosts()
        async let notificationsTask = APIService.shared.fetchNotifications()
        
        do {
            let (newUsers, newPosts, newNotifications) = try await (usersTask, postsTask, notificationsTask)
            
            users = newUsers
            posts = newPosts
            notifications = newNotifications
            
        } catch {
            print("Error refreshing data: \(error)")
            // Handle error appropriately
        }
        
        isRefreshing = false
    }
}

struct MultiSourceListView: View {
    @StateObject private var viewModel = MultiSourceViewModel()
    
    var body: some View {
        NavigationView {
            List {
                Section("Users") {
                    ForEach(viewModel.users) { user in
                        UserRowView(user: user)
                    }
                }
                
                Section("Posts") {
                    ForEach(viewModel.posts) { post in
                        PostRowView(post: post)
                    }
                }
                
                Section("Notifications") {
                    ForEach(viewModel.notifications) { notification in
                        NotificationRowView(notification: notification)
                    }
                }
            }
            .refreshable {
                await viewModel.refreshAll()
            }
            .navigationTitle("Dashboard")
            .task {
                await viewModel.refreshAll()
            }
        }
    }
}
</code></pre>
      </div>

      <div class="concept-box">
        <h5>2. Conditional Refresh</h5>
        <p>تحديث البيانات حسب شروط معينة</p>
      </div>

      <div class="code-container">
        <pre><code class="language-swift">
@MainActor
class ConditionalRefreshViewModel: ObservableObject {
    @Published var items: [Item] = []
    @Published var lastRefreshDate: Date?
    @Published var isRefreshing = false
    
    private let refreshThreshold: TimeInterval = 300 // 5 minutes
    
    func refreshIfNeeded() async {
        let now = Date()
        
        // Check if we need to refresh
        if let lastRefresh = lastRefreshDate {
            let timeSinceLastRefresh = now.timeIntervalSince(lastRefresh)
            if timeSinceLastRefresh < refreshThreshold {
                print("Data is fresh, skipping refresh")
                return
            }
        }
        
        await forceRefresh()
    }
    
    func forceRefresh() async {
        isRefreshing = true
        
        do {
            let newItems = try await APIService.shared.fetchItems()
            items = newItems
            lastRefreshDate = Date()
            
        } catch {
            print("Error refreshing: \(error)")
        }
        
        isRefreshing = false
    }
}

struct ConditionalRefreshListView: View {
    @StateObject private var viewModel = ConditionalRefreshViewModel()
    
    var body: some View {
        NavigationView {
            List(viewModel.items) { item in
                ItemRowView(item: item)
            }
            .refreshable {
                await viewModel.forceRefresh() // Always refresh on pull
            }
            .navigationTitle("Items")
            .task {
                await viewModel.refreshIfNeeded() // Smart refresh on appear
            }
            .onReceive(NotificationCenter.default.publisher(for: UIApplication.willEnterForegroundNotification)) { _ in
                Task {
                    await viewModel.refreshIfNeeded()
                }
            }
        }
    }
}
</code></pre>
      </div>

      <h2 class="section-title">📱 Real-time Updates with Combine</h2>

      <div class="concept-box">
        <h5>تحديث البيانات باستخدام Combine للـ real-time updates</h5>
      </div>

      <div class="code-container">
        <pre><code class="language-swift">
import Combine

@MainActor
class RealtimeViewModel: ObservableObject {
    @Published var items: [Item] = []
    @Published var connectionStatus: ConnectionStatus = .disconnected
    
    private var cancellables = Set<AnyCancellable>()
    private let webSocketService = WebSocketService()
    
    enum ConnectionStatus {
        case connected, disconnected, reconnecting
    }
    
    init() {
        setupRealtimeUpdates()
    }
    
    private func setupRealtimeUpdates() {
        // Listen for real-time updates
        webSocketService.itemUpdates
            .receive(on: DispatchQueue.main)
            .sink { [weak self] updatedItem in
                self?.updateItem(updatedItem)
            }
            .store(in: &cancellables)
        
        // Listen for connection status
        webSocketService.connectionStatus
            .receive(on: DispatchQueue.main)
            .assign(to: \.connectionStatus, on: self)
            .store(in: &cancellables)
    }
    
    func refreshData() async {
        do {
            let newItems = try await APIService.shared.fetchItems()
            items = newItems
        } catch {
            print("Error refreshing: \(error)")
        }
    }
    
    private func updateItem(_ updatedItem: Item) {
        if let index = items.firstIndex(where: { $0.id == updatedItem.id }) {
            items[index] = updatedItem
        } else {
            items.append(updatedItem)
        }
    }
    
    func connectWebSocket() {
        webSocketService.connect()
    }
    
    func disconnectWebSocket() {
        webSocketService.disconnect()
    }
}

struct RealtimeListView: View {
    @StateObject private var viewModel = RealtimeViewModel()
    
    var body: some View {
        NavigationView {
            VStack {
                HStack {
                    Text("Connection: ")
                    Text(statusText)
                        .foregroundColor(statusColor)
                    Spacer()
                }
                .padding(.horizontal)
                
                List(viewModel.items) { item in
                    ItemRowView(item: item)
                }
                .refreshable {
                    await viewModel.refreshData()
                }
            }
            .navigationTitle("Real-time Items")
            .task {
                viewModel.connectWebSocket()
                await viewModel.refreshData()
            }
            .onDisappear {
                viewModel.disconnectWebSocket()
            }
        }
    }
    
    private var statusText: String {
        switch viewModel.connectionStatus {
        case .connected: return "Connected"
        case .disconnected: return "Disconnected"
        case .reconnecting: return "Reconnecting..."
        }
    }
    
    private var statusColor: Color {
        switch viewModel.connectionStatus {
        case .connected: return .green
        case .disconnected: return .red
        case .reconnecting: return .orange
        }
    }
}
</code></pre>
      </div>

      <h2 class="section-title">🎯 Best Practices</h2>

      <div class="highlight-box">
        <h4>نصائح هامة لـ List Refresh:</h4>
        <ol>
          <li><strong>استخدم refreshable:</strong> للـ iOS 15+ projects</li>
          <li><strong>Task modifier:</strong> للتحميل الأولي مع automatic cancellation</li>
          <li><strong>Error Handling:</strong> اتعامل مع errors بشكل مناسب</li>
          <li><strong>Loading States:</strong> وضح للمستخدم إن البيانات بتتحمل</li>
          <li><strong>Smart Refresh:</strong> لا تحمل البيانات إلا لو محتاج</li>
          <li><strong>Background Refresh:</strong> حدث البيانات لما التطبيق يرجع foreground</li>
        </ol>
      </div>

      <h2 class="section-title">📊 الخلاصة</h2>

      <div class="concept-box">
        <p>
          <strong>List Refresh في SwiftUI:</strong>
        </p>
        <ul>
          <li><strong>refreshable modifier:</strong> الطريقة الأحدث والأبسط</li>
          <li><strong>task modifier:</strong> للتحميل الأولي مع async/await</li>
          <li><strong>Custom solutions:</strong> للـ iOS 14 support</li>
          <li><strong>Real-time updates:</strong> باستخدام WebSocket أو Server-Sent Events</li>
          <li><strong>Smart refresh:</strong> تحديث البيانات حسب الحاجة</li>
        </ul>
      </div>

      <div class="mt-4">
        <a href="../SwiftUI_Interview_Questions.html" class="back-btn">
          ← العودة للأسئلة الرئيسية
        </a>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/autoloader/prism-autoloader.min.js"></script>
  </body>
</html>