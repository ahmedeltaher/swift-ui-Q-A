<!DOCTYPE html>
<html lang="ar" dir="rtl">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>List Refresh in SwiftUI</title>
    
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-tomorrow.min.css" rel="stylesheet">
    
    <style>
      body {
        font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
        line-height: 1.6;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        direction: rtl;
      }
      .container {
        background: white;
        border-radius: 15px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        margin: 2rem auto;
        padding: 2rem;
        max-width: 1200px;
      }
      .question-title {
        color: #2c3e50;
        border-bottom: 3px solid #3498db;
        padding-bottom: 1rem;
        margin-bottom: 2rem;
        font-weight: 700;
      }
      .section-title {
        color: #e74c3c;
        margin: 2rem 0 1rem 0;
        font-weight: 600;
        font-size: 1.3rem;
      }
      .code-container {
        background: #2d3748;
        border-radius: 10px;
        padding: 1.5rem;
        margin: 1rem 0;
        overflow-x: auto;
      }
      .code-container code {
        color: #e2e8f0;
        font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
      }
      .highlight-box {
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
        padding: 1.5rem;
        border-radius: 10px;
        margin: 1.5rem 0;
      }
      .back-btn {
        background: linear-gradient(135deg, #667eea, #764ba2);
        border: none;
        color: white;
        padding: 0.7rem 1.5rem;
        border-radius: 25px;
        font-weight: 600;
        transition: transform 0.3s ease;
        text-decoration: none;
        display: inline-block;
        margin-bottom: 2rem;
      }
      .back-btn:hover {
        transform: translateY(-2px);
        color: white;
      }
      .concept-box {
        background: #f8f9fa;
        border-left: 4px solid #3498db;
        padding: 1rem 1.5rem;
        margin: 1rem 0;
        border-radius: 0 8px 8px 0;
      }
      .warning-box {
        background: #fff3cd;
        border-left: 4px solid #ffc107;
        padding: 1rem 1.5rem;
        margin: 1rem 0;
        border-radius: 0 8px 8px 0;
      }
      .success-box {
        background: #d1edff;
        border-left: 4px solid #17a2b8;
        padding: 1rem 1.5rem;
        margin: 1rem 0;
        border-radius: 0 8px 8px 0;
      }
    </style>
  </head>

  <body>
    <div class="container">
      <a href="../SwiftUI_Interview_Questions.html" class="back-btn">
        â† Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„ØµÙØ­Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
      </a>

      <h1 class="question-title">
        How do you refresh a List in SwiftUI? (pull-to-refresh, task modifier)
      </h1>

      <div class="highlight-box">
        <h4>ğŸ”„ Ø§Ù„ÙÙƒØ±Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©</h4>
        <p>
          <strong>List Refresh</strong> ÙÙŠ SwiftUI Ø¨ÙŠØªÙ… Ø¨Ø·Ø±Ù‚ Ù…Ø®ØªÙ„ÙØ© Ø­Ø³Ø¨ iOS version ÙˆØ§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…Ø·Ù„ÙˆØ¨. 
          Ù…Ù† Pull-to-Refresh Ø§Ù„Ù…Ø¹ØªØ§Ø¯ Ù„Ù„Ù€ Task modifier Ø§Ù„Ø¬Ø¯ÙŠØ¯ Ù…Ø¹ iOS 15+.
        </p>
      </div>

      <h2 class="section-title">ğŸ“ Ø§Ù„Ø´Ø±Ø­ Ø¨Ø§Ù„Ø¹Ø±Ø¨ÙŠ</h2>
      <p>
        ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙÙŠ List Ù…Ù† Ø£Ù‡Ù… Ø§Ù„Ù…Ù…ÙŠØ²Ø§Øª ÙÙŠ Ø£ÙŠ ØªØ·Ø¨ÙŠÙ‚. SwiftUI Ø¨ÙŠÙˆÙØ± Ø·Ø±Ù‚ Ù…Ø®ØªÙ„ÙØ© Ù„Ù„Ù€ refreshØŒ 
        Ù…Ù† Ø§Ù„Ù€ pull-to-refresh Ø§Ù„ØªÙ‚Ù„ÙŠØ¯ÙŠ Ù„Ù„Ù€ task modifier Ø§Ù„Ù„ÙŠ Ø¨ÙŠØ´ØªØºÙ„ Ù…Ø¹ async/await.
        ÙƒÙ„ Ø·Ø±ÙŠÙ‚Ø© Ù„Ù‡Ø§ Ø§Ø³ØªØ®Ø¯Ø§Ù…Ø§ØªÙ‡Ø§ Ø§Ù„Ù…Ù†Ø§Ø³Ø¨Ø©.
      </p>

      <h2 class="section-title">ğŸ¯ iOS 15+ Modern Approach: refreshable</h2>

      <div class="success-box">
        <h5>1. Built-in Pull-to-Refresh</h5>
        <p>Ø§Ù„Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø£Ø³Ù‡Ù„ ÙˆØ§Ù„Ø£Ø­Ø¯Ø« Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… refreshable modifier</p>
      </div>

      <div class="code-container">
        <pre><code class="language-swift">
struct ModernListView: View {
    @StateObject private var viewModel = DataViewModel()
    
    var body: some View {
        NavigationView {
            List(viewModel.items, id: \.id) { item in
                ItemRowView(item: item)
            }
            .refreshable {
                await viewModel.refreshData()
            }
            .navigationTitle("Items")
        }
    }
}

@MainActor
class DataViewModel: ObservableObject {
    @Published var items: [Item] = []
    @Published var isLoading = false
    
    func refreshData() async {
        isLoading = true
        
        do {
            // Simulate network call
            try await Task.sleep(nanoseconds: 1_000_000_000) // 1 second
            
            // Fetch new data
            let newItems = await APIService.shared.fetchItems()
            items = newItems
            
        } catch {
            print("Error refreshing data: \(error)")
        }
        
        isLoading = false
    }
    
    func loadInitialData() async {
        await refreshData()
    }
}
</code></pre>
      </div>

      <h2 class="section-title">âš¡ Task Modifier for Initial Loading</h2>

      <div class="concept-box">
        <h5>Ø§Ø³ØªØ®Ø¯Ø§Ù… Task modifier Ù„Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø£ÙˆÙ„ÙŠ</h5>
        <p>Task modifier Ø¨ÙŠØ³Ù…Ø­ Ø¨ØªØ´ØºÙŠÙ„ async operations Ø¹Ù†Ø¯ Ø¸Ù‡ÙˆØ± Ø§Ù„Ù€ view</p>
      </div>

      <div class="code-container">
        <pre><code class="language-swift">
struct ItemListView: View {
    @StateObject private var viewModel = ItemViewModel()
    
    var body: some View {
        NavigationView {
            Group {
                if viewModel.items.isEmpty && viewModel.isLoading {
                    ProgressView("Loading...")
                } else {
                    List {
                        ForEach(viewModel.items) { item in
                            ItemRowView(item: item)
                        }
                    }
                    .refreshable {
                        await viewModel.refreshData()
                    }
                }
            }
            .navigationTitle("Items")
            .task {
                // This runs when view appears and automatically cancels when view disappears
                await viewModel.loadInitialData()
            }
        }
    }
}

struct ItemRowView: View {
    let item: Item
    
    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            Text(item.title)
                .font(.headline)
            Text(item.subtitle)
                .font(.caption)
                .foregroundColor(.secondary)
        }
        .padding(.vertical, 2)
    }
}
</code></pre>
      </div>

      <h2 class="section-title">ğŸ”„ Custom Pull-to-Refresh (Pre-iOS 15)</h2>

      <div class="warning-box">
        <h5>Ù„Ù„Ù…Ø´Ø§Ø±ÙŠØ¹ Ø§Ù„Ù„ÙŠ Ø¨ØªØ¯Ø¹Ù… iOS 14 ÙˆØ£Ù‚Ù„</h5>
        <p>ØªØ·Ø¨ÙŠÙ‚ custom pull-to-refresh Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… UIViewRepresentable</p>
      </div>

      <div class="code-container">
        <pre><code class="language-swift">
struct RefreshableScrollView<Content: View>: UIViewRepresentable {
    let content: Content
    let onRefresh: () async -> Void
    
    init(@ViewBuilder content: () -> Content, onRefresh: @escaping () async -> Void) {
        self.content = content()
        self.onRefresh = onRefresh
    }
    
    func makeUIView(context: Context) -> UIScrollView {
        let scrollView = UIScrollView()
        let refreshControl = UIRefreshControl()
        
        refreshControl.addTarget(
            context.coordinator,
            action: #selector(Coordinator.handleRefresh),
            for: .valueChanged
        )
        
        scrollView.refreshControl = refreshControl
        
        let hostingController = UIHostingController(rootView: content)
        hostingController.view.translatesAutoresizingMaskIntoConstraints = false
        
        scrollView.addSubview(hostingController.view)
        
        NSLayoutConstraint.activate([
            hostingController.view.leadingAnchor.constraint(equalTo: scrollView.leadingAnchor),
            hostingController.view.trailingAnchor.constraint(equalTo: scrollView.trailingAnchor),
            hostingController.view.topAnchor.constraint(equalTo: scrollView.topAnchor),
            hostingController.view.bottomAnchor.constraint(equalTo: scrollView.bottomAnchor),
            hostingController.view.widthAnchor.constraint(equalTo: scrollView.widthAnchor)
        ])
        
        context.coordinator.refreshControl = refreshControl
        
        return scrollView
    }
    
    func updateUIView(_ uiView: UIScrollView, context: Context) {
        // Update if needed
    }
    
    func makeCoordinator() -> Coordinator {
        Coordinator(onRefresh: onRefresh)
    }
    
    class Coordinator: NSObject {
        let onRefresh: () async -> Void
        var refreshControl: UIRefreshControl?
        
        init(onRefresh: @escaping () async -> Void) {
            self.onRefresh = onRefresh
        }
        
        @objc func handleRefresh() {
            Task {
                await onRefresh()
                await MainActor.run {
                    refreshControl?.endRefreshing()
                }
            }
        }
    }
}

// Usage
struct LegacyListView: View {
    @StateObject private var viewModel = DataViewModel()
    
    var body: some View {
        RefreshableScrollView(
            content: {
                LazyVStack {
                    ForEach(viewModel.items) { item in
                        ItemRowView(item: item)
                    }
                }
            },
            onRefresh: {
                await viewModel.refreshData()
            }
        )
    }
}
</code></pre>
      </div>

      <h2 class="section-title">ğŸ›ï¸ Advanced Refresh Patterns</h2>

      <div class="success-box">
        <h5>1. Multiple Data Sources</h5>
        <p>ØªØ­Ø¯ÙŠØ« Ø¹Ø¯Ø© Ù…ØµØ§Ø¯Ø± Ø¨ÙŠØ§Ù†Ø§Øª ÙÙŠ Ù†ÙØ³ Ø§Ù„ÙˆÙ‚Øª</p>
      </div>

      <div class="code-container">
        <pre><code class="language-swift">
@MainActor
class MultiSourceViewModel: ObservableObject {
    @Published var users: [User] = []
    @Published var posts: [Post] = []
    @Published var notifications: [Notification] = []
    @Published var isRefreshing = false
    
    func refreshAll() async {
        isRefreshing = true
        
        async let usersTask = APIService.shared.fetchUsers()
        async let postsTask = APIService.shared.fetchPosts()
        async let notificationsTask = APIService.shared.fetchNotifications()
        
        do {
            let (newUsers, newPosts, newNotifications) = try await (usersTask, postsTask, notificationsTask)
            
            users = newUsers
            posts = newPosts
            notifications = newNotifications
            
        } catch {
            print("Error refreshing data: \(error)")
            // Handle error appropriately
        }
        
        isRefreshing = false
    }
}

struct MultiSourceListView: View {
    @StateObject private var viewModel = MultiSourceViewModel()
    
    var body: some View {
        NavigationView {
            List {
                Section("Users") {
                    ForEach(viewModel.users) { user in
                        UserRowView(user: user)
                    }
                }
                
                Section("Posts") {
                    ForEach(viewModel.posts) { post in
                        PostRowView(post: post)
                    }
                }
                
                Section("Notifications") {
                    ForEach(viewModel.notifications) { notification in
                        NotificationRowView(notification: notification)
                    }
                }
            }
            .refreshable {
                await viewModel.refreshAll()
            }
            .navigationTitle("Dashboard")
            .task {
                await viewModel.refreshAll()
            }
        }
    }
}
</code></pre>
      </div>

      <div class="concept-box">
        <h5>2. Conditional Refresh</h5>
        <p>ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø­Ø³Ø¨ Ø´Ø±ÙˆØ· Ù…Ø¹ÙŠÙ†Ø©</p>
      </div>

      <div class="code-container">
        <pre><code class="language-swift">
@MainActor
class ConditionalRefreshViewModel: ObservableObject {
    @Published var items: [Item] = []
    @Published var lastRefreshDate: Date?
    @Published var isRefreshing = false
    
    private let refreshThreshold: TimeInterval = 300 // 5 minutes
    
    func refreshIfNeeded() async {
        let now = Date()
        
        // Check if we need to refresh
        if let lastRefresh = lastRefreshDate {
            let timeSinceLastRefresh = now.timeIntervalSince(lastRefresh)
            if timeSinceLastRefresh < refreshThreshold {
                print("Data is fresh, skipping refresh")
                return
            }
        }
        
        await forceRefresh()
    }
    
    func forceRefresh() async {
        isRefreshing = true
        
        do {
            let newItems = try await APIService.shared.fetchItems()
            items = newItems
            lastRefreshDate = Date()
            
        } catch {
            print("Error refreshing: \(error)")
        }
        
        isRefreshing = false
    }
}

struct ConditionalRefreshListView: View {
    @StateObject private var viewModel = ConditionalRefreshViewModel()
    
    var body: some View {
        NavigationView {
            List(viewModel.items) { item in
                ItemRowView(item: item)
            }
            .refreshable {
                await viewModel.forceRefresh() // Always refresh on pull
            }
            .navigationTitle("Items")
            .task {
                await viewModel.refreshIfNeeded() // Smart refresh on appear
            }
            .onReceive(NotificationCenter.default.publisher(for: UIApplication.willEnterForegroundNotification)) { _ in
                Task {
                    await viewModel.refreshIfNeeded()
                }
            }
        }
    }
}
</code></pre>
      </div>

      <h2 class="section-title">ğŸ“± Real-time Updates with Combine</h2>

      <div class="concept-box">
        <h5>ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Combine Ù„Ù„Ù€ real-time updates</h5>
      </div>

      <div class="code-container">
        <pre><code class="language-swift">
import Combine

@MainActor
class RealtimeViewModel: ObservableObject {
    @Published var items: [Item] = []
    @Published var connectionStatus: ConnectionStatus = .disconnected
    
    private var cancellables = Set<AnyCancellable>()
    private let webSocketService = WebSocketService()
    
    enum ConnectionStatus {
        case connected, disconnected, reconnecting
    }
    
    init() {
        setupRealtimeUpdates()
    }
    
    private func setupRealtimeUpdates() {
        // Listen for real-time updates
        webSocketService.itemUpdates
            .receive(on: DispatchQueue.main)
            .sink { [weak self] updatedItem in
                self?.updateItem(updatedItem)
            }
            .store(in: &cancellables)
        
        // Listen for connection status
        webSocketService.connectionStatus
            .receive(on: DispatchQueue.main)
            .assign(to: \.connectionStatus, on: self)
            .store(in: &cancellables)
    }
    
    func refreshData() async {
        do {
            let newItems = try await APIService.shared.fetchItems()
            items = newItems
        } catch {
            print("Error refreshing: \(error)")
        }
    }
    
    private func updateItem(_ updatedItem: Item) {
        if let index = items.firstIndex(where: { $0.id == updatedItem.id }) {
            items[index] = updatedItem
        } else {
            items.append(updatedItem)
        }
    }
    
    func connectWebSocket() {
        webSocketService.connect()
    }
    
    func disconnectWebSocket() {
        webSocketService.disconnect()
    }
}

struct RealtimeListView: View {
    @StateObject private var viewModel = RealtimeViewModel()
    
    var body: some View {
        NavigationView {
            VStack {
                HStack {
                    Text("Connection: ")
                    Text(statusText)
                        .foregroundColor(statusColor)
                    Spacer()
                }
                .padding(.horizontal)
                
                List(viewModel.items) { item in
                    ItemRowView(item: item)
                }
                .refreshable {
                    await viewModel.refreshData()
                }
            }
            .navigationTitle("Real-time Items")
            .task {
                viewModel.connectWebSocket()
                await viewModel.refreshData()
            }
            .onDisappear {
                viewModel.disconnectWebSocket()
            }
        }
    }
    
    private var statusText: String {
        switch viewModel.connectionStatus {
        case .connected: return "Connected"
        case .disconnected: return "Disconnected"
        case .reconnecting: return "Reconnecting..."
        }
    }
    
    private var statusColor: Color {
        switch viewModel.connectionStatus {
        case .connected: return .green
        case .disconnected: return .red
        case .reconnecting: return .orange
        }
    }
}
</code></pre>
      </div>

      <h2 class="section-title">ğŸ¯ Best Practices</h2>

      <div class="highlight-box">
        <h4>Ù†ØµØ§Ø¦Ø­ Ù‡Ø§Ù…Ø© Ù„Ù€ List Refresh:</h4>
        <ol>
          <li><strong>Ø§Ø³ØªØ®Ø¯Ù… refreshable:</strong> Ù„Ù„Ù€ iOS 15+ projects</li>
          <li><strong>Task modifier:</strong> Ù„Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø£ÙˆÙ„ÙŠ Ù…Ø¹ automatic cancellation</li>
          <li><strong>Error Handling:</strong> Ø§ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ errors Ø¨Ø´ÙƒÙ„ Ù…Ù†Ø§Ø³Ø¨</li>
          <li><strong>Loading States:</strong> ÙˆØ¶Ø­ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¥Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨ØªØªØ­Ù…Ù„</li>
          <li><strong>Smart Refresh:</strong> Ù„Ø§ ØªØ­Ù…Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¥Ù„Ø§ Ù„Ùˆ Ù…Ø­ØªØ§Ø¬</li>
          <li><strong>Background Refresh:</strong> Ø­Ø¯Ø« Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ù…Ø§ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ ÙŠØ±Ø¬Ø¹ foreground</li>
        </ol>
      </div>

      <h2 class="section-title">ğŸ“Š Ø§Ù„Ø®Ù„Ø§ØµØ©</h2>

      <div class="concept-box">
        <p>
          <strong>List Refresh ÙÙŠ SwiftUI:</strong>
        </p>
        <ul>
          <li><strong>refreshable modifier:</strong> Ø§Ù„Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø£Ø­Ø¯Ø« ÙˆØ§Ù„Ø£Ø¨Ø³Ø·</li>
          <li><strong>task modifier:</strong> Ù„Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø£ÙˆÙ„ÙŠ Ù…Ø¹ async/await</li>
          <li><strong>Custom solutions:</strong> Ù„Ù„Ù€ iOS 14 support</li>
          <li><strong>Real-time updates:</strong> Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… WebSocket Ø£Ùˆ Server-Sent Events</li>
          <li><strong>Smart refresh:</strong> ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø­Ø³Ø¨ Ø§Ù„Ø­Ø§Ø¬Ø©</li>
        </ul>
      </div>

      <div class="mt-4">
        <a href="../SwiftUI_Interview_Questions.html" class="back-btn">
          â† Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
        </a>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/autoloader/prism-autoloader.min.js"></script>
  </body>
</html>