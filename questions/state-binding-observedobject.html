<!DOCTYPE html>
<html lang="ar" dir="rtl">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>What is the difference between @State, @Binding, @ObservedObject, @EnvironmentObject, @StateObject?</title>
  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <!-- Custom CSS -->
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #121212;
      color: #e0e0e0;
      padding: 20px;
    }

    .card {
      margin-bottom: 25px;
      border-radius: 15px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
      overflow: hidden;
      border: none;
    }

    .basic-level {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }

    .card-header {
      color: white;
      font-weight: bold;
      border-radius: 0 !important;
      padding: 20px;
      background: rgba(0, 0, 0, 0.1);
      border-bottom: 1px solid rgba(255, 255, 255, 0.2);
    }

    .card-body {
      padding: 25px;
      line-height: 1.8;
      color: white;
    }

    .main-title {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      text-align: center;
      margin-bottom: 30px;
      font-size: 2.5rem;
      font-weight: bold;
      filter: brightness(1.2);
      text-shadow: 0 0 15px rgba(102, 126, 234, 0.5);
    }

    .content-container {
      max-width: 900px;
      margin: 0 auto;
    }

    .answer-section {
      background-color: rgba(255, 255, 255, 0.1);
      border-radius: 15px;
      padding: 25px;
      margin-bottom: 25px;
      direction: ltr;
      text-align: left;
    }

    .explanation-section {
      background-color: rgba(255, 255, 255, 0.05);
      border-radius: 15px;
      padding: 25px;
      margin-bottom: 25px;
    }

    .answer-title,
    .explanation-title {
      font-weight: bold;
      margin-bottom: 15px;
      color: #e0e0e0;
    }

    .code-block {
      background-color: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      padding: 15px;
      margin: 15px 0;
      overflow-x: auto;
    }

    pre {
      color: #e0e0e0;
      margin: 0;
    }

    .back-button {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 8px;
      padding: 10px 20px;
      margin-bottom: 20px;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .back-button:hover {
      transform: translateY(-3px);
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.5);
    }

    footer {
      text-align: center;
      margin-top: 40px;
      color: #a0a0a0;
      padding: 20px;
    }

    .highlight {
      color: #f6d365;
      font-weight: bold;
    }

    table {
      width: 100%;
      margin: 20px 0;
      border-collapse: collapse;
    }

    th,
    td {
      padding: 12px 15px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    th {
      background-color: rgba(0, 0, 0, 0.2);
    }

    tr:nth-child(even) {
      background-color: rgba(255, 255, 255, 0.03);
    }
  </style>
</head>

<body>
  <div class="content-container">
    <button onclick="window.location.href='../SwiftUI_Interview_Questions.html'" class="back-button">← العودة
      للأسئلة</button>

    <h1 class="main-title">What is the difference between @State, @Binding, @ObservedObject, @EnvironmentObject,
      @StateObject?</h1>

    <div class="card basic-level">
      <div class="card-header">
        <h3 class="mb-0">Answer in English</h3>
      </div>
      <div class="card-body">
        <div class="answer-section">
          <p>These property wrappers in SwiftUI are used for different state management scenarios:</p>

          <table>
            <tr>
              <th>Property Wrapper</th>
              <th>Purpose</th>
              <th>Scope</th>
              <th>When to Use</th>
            </tr>
            <tr>
              <td><strong>@State</strong></td>
              <td>Manages simple value types within a view</td>
              <td>Private to the view</td>
              <td>For simple view-local state (strings, numbers, booleans)</td>
            </tr>
            <tr>
              <td><strong>@Binding</strong></td>
              <td>Creates a two-way connection to a state property</td>
              <td>Passed from parent to child</td>
              <td>When a child view needs to modify its parent's state</td>
            </tr>
            <tr>
              <td><strong>@ObservedObject</strong></td>
              <td>Subscribes to an external reference type object</td>
              <td>Passed in from parent</td>
              <td>For complex state in reference types shared across views</td>
            </tr>
            <tr>
              <td><strong>@StateObject</strong></td>
              <td>Creates and manages the lifecycle of an ObservableObject</td>
              <td>Owned by the view</td>
              <td>When a view needs to create and own an ObservableObject</td>
            </tr>
            <tr>
              <td><strong>@EnvironmentObject</strong></td>
              <td>Reads an ObservableObject from the environment</td>
              <td>Global for view hierarchy</td>
              <td>For shared data across the entire app or large portions of it</td>
            </tr>
          </table>

          <p><strong>Detailed explanation:</strong></p>

          <p><strong>@State</strong> is used for simple value types (Int, String, Bool, etc.) that are private to a
            view. When the state changes, the view automatically re-renders. It's meant for simple values owned by a
            single view.</p>

          <div class="code-block">
            <pre>struct ContentView: View {
    @State private var counter = 0
    
    var body: some View {
        Button("Increment: \(counter)") {
            counter += 1
        }
    }
}</pre>
          </div>

          <p><strong>@Binding</strong> creates a two-way connection to a state variable defined elsewhere. Changes made
            through a binding are reflected back to the original source. Used when a child view needs to modify its
            parent's state.</p>

          <div class="code-block">
            <pre>struct ParentView: View {
    @State private var isOn = false
    
    var body: some View {
        ToggleView(isOn: $isOn)
    }
}

struct ToggleView: View {
    @Binding var isOn: Bool
    
    var body: some View {
        Toggle("Toggle", isOn: $isOn)
    }
}</pre>
          </div>

          <p><strong>@ObservedObject</strong> is used with external reference types conforming to ObservableObject
            protocol. It's typically passed into a view and the view subscribes to its changes, but the view doesn't own
            it or control its lifecycle.</p>

          <div class="code-block">
            <pre>class UserSettings: ObservableObject {
    @Published var username = ""
}

struct ProfileView: View {
    @ObservedObject var settings: UserSettings
    
    var body: some View {
        TextField("Username", text: $settings.username)
    }
}</pre>
          </div>

          <p><strong>@StateObject</strong> is similar to @ObservedObject but it creates and owns the instance. It
            ensures the object lives as long as the view does, even when the view redraws. Introduced in iOS 14 to solve
            lifecycle issues with @ObservedObject.</p>

          <div class="code-block">
            <pre>struct ProfileCreator: View {
    @StateObject private var settings = UserSettings()
    
    var body: some View {
        ProfileView(settings: settings)
    }
}</pre>
          </div>

          <p><strong>@EnvironmentObject</strong> allows you to share data across many views without explicitly passing
            it through each view. The object must be injected into the environment of a parent view.</p>

          <div class="code-block">
            <pre>// In App or SceneDelegate
let settings = UserSettings()
contentView.environmentObject(settings)

// In any descendant view
struct SettingsView: View {
    @EnvironmentObject var settings: UserSettings
    
    var body: some View {
        TextField("Username", text: $settings.username)
    }
}</pre>
          </div>

          <p><strong>Key differences:</strong></p>
          <ul>
            <li><strong>Ownership</strong>: @State and @StateObject are owned by the view, @ObservedObject and
              @EnvironmentObject are not.</li>
            <li><strong>Type</strong>: @State is for value types, others are for reference types (ObservableObject).
            </li>
            <li><strong>Scope</strong>: @State is view-private, @Binding is for parent-child, @EnvironmentObject is for
              the entire hierarchy.</li>
            <li><strong>Lifecycle</strong>: @StateObject preserves the instance across view redraws, @ObservedObject
              doesn't.</li>
          </ul>
        </div>
      </div>
    </div>

    <div class="explanation-section">
      <h3 class="explanation-title">الشرح بالعربي</h3>

      <p>تُستخدم هذه الـ property wrappers في SwiftUI لإدارة الحالة (state) في سيناريوهات مختلفة:</p>

      <ol>
        <li>
          <span class="highlight">@State</span>: يستخدم لإدارة قيم بسيطة داخل الـ view الواحدة.
          <ul>
            <li>مخصص للقيم البسيطة مثل النصوص والأرقام والقيم المنطقية.</li>
            <li>عندما تتغير هذه القيمة، يعاد رسم الـ view تلقائياً.</li>
            <li>يجب أن تكون خاصة (private) لأنها مصممة للاستخدام داخل الـ view فقط.</li>
          </ul>
        </li>

        <li>
          <span class="highlight">@Binding</span>: ينشئ اتصالاً ثنائي الاتجاه مع متغير حالة موجود في مكان آخر.
          <ul>
            <li>يُستخدم عندما تحتاج view ابنة لتعديل حالة موجودة في view الأب.</li>
            <li>أي تغييرات تحدث من خلال الـ binding تنعكس على المصدر الأصلي للبيانات.</li>
            <li>يتم تمريره باستخدام رمز $ (مثل $isOn).</li>
          </ul>
        </li>

        <li>
          <span class="highlight">@ObservedObject</span>: يستخدم مع الكائنات المرجعية (reference types) التي تطبق
          بروتوكول ObservableObject.
          <ul>
            <li>عادة ما يتم تمريره إلى view من الخارج.</li>
            <li>تشترك الـ view في تغييراته، لكنها لا تتحكم في دورة حياته.</li>
            <li>يمكن أن يواجه مشكلات إذا تمت إعادة إنشاء الـ view (يمكن أن يُعاد تعيينه).</li>
          </ul>
        </li>

        <li>
          <span class="highlight">@StateObject</span>: مشابه لـ ObservedObject@ لكنه ينشئ ويمتلك الكائن.
          <ul>
            <li>يضمن أن الكائن يعيش طالما أن الـ view موجودة، حتى عندما يعاد رسم الـ view.</li>
            <li>تم تقديمه في iOS 14 لحل مشكلات دورة الحياة مع ObservedObject@.</li>
            <li>يستخدم عندما تحتاج view إلى إنشاء وامتلاك ObservableObject.</li>
          </ul>
        </li>

        <li>
          <span class="highlight">@EnvironmentObject</span>: يسمح بمشاركة البيانات بين العديد من الـ views دون الحاجة
          لتمريرها صراحة عبر كل view.
          <ul>
            <li>يجب حقن الكائن في بيئة view أب باستخدام environmentObject().</li>
            <li>يمكن لأي view ابنة في الهيكل الوصول إلى الكائن.</li>
            <li>مناسب للبيانات المشتركة على مستوى التطبيق كله.</li>
          </ul>
        </li>
      </ol>

      <p><strong>الاختلافات الرئيسية:</strong></p>
      <ul>
        <li><span class="highlight">الملكية</span>: State@ و StateObject@ مملوكة للـ view، بينما ObservedObject@ و
          EnvironmentObject@ ليست كذلك.</li>
        <li><span class="highlight">النوع</span>: State@ مخصص للأنواع القيمية (value types)، بينما الآخرون للأنواع
          المرجعية (reference types) التي تطبق ObservableObject.</li>
        <li><span class="highlight">النطاق</span>: State@ خاص بالـ view، Binding@ للعلاقة بين الأب والابن،
          EnvironmentObject@ للهيكل بأكمله.</li>
        <li><span class="highlight">دورة الحياة</span>: StateObject@ يحافظ على الكائن عبر عمليات إعادة رسم الـ view،
          بينما ObservedObject@ لا يفعل ذلك.</li>
      </ul>

      <p>مثال على الاستخدام المناسب:</p>
      <ul>
        <li>استخدم <span class="highlight">State@</span> لقيمة بسيطة مثل عداد أو حالة تبديل داخل view.</li>
        <li>استخدم <span class="highlight">Binding@</span> عندما تريد أن تسمح لـ view ابنة بتعديل حالة تملكها view الأب.
        </li>
        <li>استخدم <span class="highlight">ObservedObject@</span> عندما تريد أن تتبع view التغييرات في كائن تم تمريره
          إليها.</li>
        <li>استخدم <span class="highlight">StateObject@</span> عندما تحتاج view إلى إنشاء وامتلاك كائن قابل للمراقبة.
        </li>
        <li>استخدم <span class="highlight">EnvironmentObject@</span> للبيانات المشتركة على مستوى واسع، مثل إعدادات
          المستخدم أو موضوع التطبيق.</li>
      </ul>

      <p>فهم الاختلافات بين هذه الـ property wrappers أمر أساسي لبناء تطبيقات SwiftUI بشكل صحيح، حيث أن الاختيار الخاطئ
        قد يؤدي إلى مشكلات في الأداء أو سلوك غير متوقع.</p>
    </div>

    <button onclick="window.location.href='../SwiftUI_Interview_Questions.html'" class="back-button">← العودة
      للأسئلة</button>
  </div>

  <footer>
    صفحة إجابة سؤال SwiftUI — الشرح بالعربي والإنجليزي
  </footer>
</body>

</html>