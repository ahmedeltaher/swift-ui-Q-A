<!DOCTYPE html>
<html lang="ar" dir="rtl">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SwiftUI Core Data Integration</title>
    
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-tomorrow.min.css" rel="stylesheet">
    
    <style>
      body {
        font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
        line-height: 1.6;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        direction: rtl;
      }
      .container {
        background: white;
        border-radius: 15px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        margin: 2rem auto;
        padding: 2rem;
        max-width: 1200px;
      }
      .question-title {
        color: #2c3e50;
        border-bottom: 3px solid #3498db;
        padding-bottom: 1rem;
        margin-bottom: 2rem;
        font-weight: 700;
      }
      .section-title {
        color: #e74c3c;
        margin: 2rem 0 1rem 0;
        font-weight: 600;
        font-size: 1.3rem;
      }
      .code-container {
        background: #2d3748;
        border-radius: 10px;
        padding: 1.5rem;
        margin: 1rem 0;
        overflow-x: auto;
      }
      .code-container code {
        color: #e2e8f0;
        font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
      }
      .highlight-box {
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
        padding: 1.5rem;
        border-radius: 10px;
        margin: 1.5rem 0;
      }
      .back-btn {
        background: linear-gradient(135deg, #667eea, #764ba2);
        border: none;
        color: white;
        padding: 0.7rem 1.5rem;
        border-radius: 25px;
        font-weight: 600;
        transition: transform 0.3s ease;
        text-decoration: none;
        display: inline-block;
        margin-bottom: 2rem;
      }
      .back-btn:hover {
        transform: translateY(-2px);
        color: white;
      }
      .concept-box {
        background: #f8f9fa;
        border-left: 4px solid #3498db;
        padding: 1rem 1.5rem;
        margin: 1rem 0;
        border-radius: 0 8px 8px 0;
      }
      .warning-box {
        background: #fff3cd;
        border-left: 4px solid #ffc107;
        padding: 1rem 1.5rem;
        margin: 1rem 0;
        border-radius: 0 8px 8px 0;
      }
      .success-box {
        background: #d1edff;
        border-left: 4px solid #17a2b8;
        padding: 1rem 1.5rem;
        margin: 1rem 0;
        border-radius: 0 8px 8px 0;
      }
    </style>
  </head>

  <body>
    <div class="container">
      <a href="../SwiftUI_Interview_Questions.html" class="back-btn">
        ‚Üê ÿßŸÑÿπŸàÿØÿ© ŸÑŸÑÿµŸÅÿ≠ÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©
      </a>

      <h1 class="question-title">
        How does SwiftUI integrate with Core Data natively?
      </h1>

      <div class="highlight-box">
        <h4>üóÉÔ∏è ÿßŸÑŸÅŸÉÿ±ÿ© ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿäÿ©</h4>
        <p>
          <strong>SwiftUI Core Data Integration</strong> ÿ®ŸäŸàŸÅÿ± native support ŸÖŸÜ ÿÆŸÑÿßŸÑ @FetchRequest Ÿà @Environment 
          ŸÑŸÑŸÄ managed object context. ÿØŸá ÿ®ŸäÿÆŸÑŸä ÿßŸÑŸÄ data binding ŸÖÿπ Core Data seamless ŸàŸÖÿ™ÿ≤ÿßŸÖŸÜ ÿ™ŸÑŸÇÿßÿ¶ŸäÿßŸã ŸÖÿπ ÿßŸÑŸÄ UI.
        </p>
      </div>

      <h2 class="section-title">üìù ÿßŸÑÿ¥ÿ±ÿ≠ ÿ®ÿßŸÑÿπÿ±ÿ®Ÿä</h2>
      <p>
        SwiftUI ÿπŸÜÿØŸá integration ŸÖÿØŸÖÿ¨ ŸÖÿπ Core Data ÿ®ÿ∑ÿ±ŸäŸÇÿ© declarative. ŸÖÿ¥ ŸÖÿ≠ÿ™ÿßÿ¨ 
        ÿ™ÿπŸÖŸÑ manual setup ŸÖÿπŸÇÿØÿå ÿ®ÿ≥ ÿ™ÿ≥ÿ™ÿÆÿØŸÖ @FetchRequest ÿπÿ¥ÿßŸÜ ÿ™ÿ¨Ÿäÿ® ÿßŸÑŸÄ data 
        Ÿà @Environment ÿπÿ¥ÿßŸÜ ÿ™ÿßÿÆÿØ ÿßŸÑŸÄ contextÿå ŸàÿßŸÑŸÄ UI ŸáŸäÿ™ÿ≠ÿØÿ´ ÿ™ŸÑŸÇÿßÿ¶ŸäÿßŸã ŸÑŸÖÿß ÿßŸÑŸÄ data Ÿäÿ™ÿ∫Ÿäÿ±.
      </p>

      <h2 class="section-title">üéØ Core Data Stack Setup</h2>

      <div class="success-box">
        <h5>1. Setting up Core Data Stack</h5>
        <p>ÿ•ÿπÿØÿßÿØ ÿßŸÑŸÄ Core Data stack ŸÑŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ŸÖÿπ SwiftUI</p>
      </div>

      <div class="code-container">
        <pre><code class="language-swift">
import CoreData
import SwiftUI

// === Core Data Stack Manager ===
class CoreDataManager: ObservableObject {
    static let shared = CoreDataManager()
    
    // Persistent Container
    lazy var persistentContainer: NSPersistentContainer = {
        let container = NSPersistentContainer(name: "DataModel") // Your .xcdatamodeld file name
        
        container.loadPersistentStores { description, error in
            if let error = error {
                print("Core Data failed to load: \(error.localizedDescription)")
                fatalError("Core Data error: \(error)")
            }
            
            // Enable automatic merging from parent context
            container.viewContext.automaticallyMergesChangesFromParent = true
            
            // Set merge policy
            container.viewContext.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy
        }
        
        return container
    }()
    
    // Main context (for UI operations)
    var mainContext: NSManagedObjectContext {
        return persistentContainer.viewContext
    }
    
    // Background context (for heavy operations)
    func backgroundContext() -> NSManagedObjectContext {
        return persistentContainer.newBackgroundContext()
    }
    
    // Save context
    func save() {
        let context = persistentContainer.viewContext
        
        if context.hasChanges {
            do {
                try context.save()
                print("‚úÖ Core Data saved successfully")
            } catch {
                print("‚ùå Failed to save Core Data: \(error)")
            }
        }
    }
    
    // Save background context
    func saveBackground(context: NSManagedObjectContext) {
        if context.hasChanges {
            do {
                try context.save()
                print("‚úÖ Background context saved successfully")
            } catch {
                print("‚ùå Failed to save background context: \(error)")
            }
        }
    }
}

// === App Entry Point ===
@main
struct CoreDataApp: App {
    let coreDataManager = CoreDataManager.shared
    
    var body: some Scene {
        WindowGroup {
            ContentView()
                .environment(\.managedObjectContext, coreDataManager.mainContext)
                .environmentObject(coreDataManager)
        }
    }
}

// === Sample Core Data Entity ===
// Create in your .xcdatamodeld file:
// Entity: Person
// Attributes: 
//   - name: String
//   - email: String  
//   - age: Int16
//   - dateCreated: Date
//   - isActive: Boolean

// Then generate NSManagedObject subclass or use the following extension:
extension Person {
    static func create(
        in context: NSManagedObjectContext,
        name: String,
        email: String,
        age: Int16
    ) -> Person {
        let person = Person(context: context)
        person.name = name
        person.email = email
        person.age = age
        person.dateCreated = Date()
        person.isActive = true
        return person
    }
}
</code></pre>
      </div>

      <h2 class="section-title">üìã @FetchRequest Implementation</h2>

      <div class="concept-box">
        <h5>ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ @FetchRequest ŸÑŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ™ŸÅÿßÿπŸÑŸäÿ©</h5>
        <p>ŸÉŸäŸÅŸäÿ© ÿ¨ŸÑÿ® Ÿàÿπÿ±ÿ∂ ÿßŸÑŸÄ Core Data entities ŸÅŸä SwiftUI</p>
      </div>

      <div class="code-container">
        <pre><code class="language-swift">
import SwiftUI
import CoreData

// === Basic FetchRequest Usage ===
struct PersonListView: View {
    // Basic fetch request - gets all Person entities
    @FetchRequest(
        entity: Person.entity(),
        sortDescriptors: [NSSortDescriptor(keyPath: \Person.name, ascending: true)]
    ) var people: FetchedResults<Person>
    
    // Access to managed object context
    @Environment(\.managedObjectContext) private var context
    
    var body: some View {
        NavigationView {
            List {
                ForEach(people, id: \.objectID) { person in
                    PersonRowView(person: person)
                }
                .onDelete(perform: deletePeople)
            }
            .navigationTitle("People")
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Add Person") {
                        addSamplePerson()
                    }
                }
            }
        }
    }
    
    private func addSamplePerson() {
        withAnimation {
            let newPerson = Person.create(
                in: context,
                name: "Ahmed \(Int.random(in: 1...100))",
                email: "ahmed@example.com",
                age: Int16.random(in: 18...80)
            )
            
            CoreDataManager.shared.save()
        }
    }
    
    private func deletePeople(offsets: IndexSet) {
        withAnimation {
            offsets.map { people[$0] }.forEach(context.delete)
            CoreDataManager.shared.save()
        }
    }
}

struct PersonRowView: View {
    @ObservedObject var person: Person
    
    var body: some View {
        HStack {
            VStack(alignment: .leading) {
                Text(person.name ?? "Unknown")
                    .font(.headline)
                
                Text(person.email ?? "No email")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            
            Spacer()
            
            VStack(alignment: .trailing) {
                Text("Age: \(person.age)")
                    .font(.caption)
                
                Circle()
                    .fill(person.isActive ? Color.green : Color.red)
                    .frame(width: 8, height: 8)
            }
        }
        .padding(.vertical, 2)
    }
}

// === Advanced FetchRequest with Predicates ===
struct FilteredPersonListView: View {
    @State private var searchText = ""
    @State private var showActiveOnly = false
    @State private var sortOption: SortOption = .name
    
    enum SortOption: String, CaseIterable {
        case name = "Name"
        case age = "Age"
        case dateCreated = "Date Created"
        
        var sortDescriptor: NSSortDescriptor {
            switch self {
            case .name:
                return NSSortDescriptor(keyPath: \Person.name, ascending: true)
            case .age:
                return NSSortDescriptor(keyPath: \Person.age, ascending: false)
            case .dateCreated:
                return NSSortDescriptor(keyPath: \Person.dateCreated, ascending: false)
            }
        }
    }
    
    var body: some View {
        NavigationView {
            VStack {
                // Search and Filter Controls
                VStack {
                    TextField("Search people...", text: $searchText)
                        .textFieldStyle(.roundedBorder)
                    
                    HStack {
                        Toggle("Active Only", isOn: $showActiveOnly)
                        
                        Spacer()
                        
                        Picker("Sort by", selection: $sortOption) {
                            ForEach(SortOption.allCases, id: \.self) { option in
                                Text(option.rawValue).tag(option)
                            }
                        }
                        .pickerStyle(.menu)
                    }
                }
                .padding()
                
                // Dynamic FetchRequest View
                DynamicPersonListView(
                    searchText: searchText,
                    showActiveOnly: showActiveOnly,
                    sortDescriptor: sortOption.sortDescriptor
                )
            }
            .navigationTitle("Filtered People")
        }
    }
}

struct DynamicPersonListView: View {
    let searchText: String
    let showActiveOnly: Bool
    let sortDescriptor: NSSortDescriptor
    
    @Environment(\.managedObjectContext) private var context
    
    var body: some View {
        // Dynamic FetchRequest based on parameters
        DynamicFetchRequestView(
            predicate: buildPredicate(),
            sortDescriptors: [sortDescriptor]
        ) { (people: FetchedResults<Person>) in
            List {
                ForEach(people, id: \.objectID) { person in
                    PersonRowView(person: person)
                }
                .onDelete { offsets in
                    deletePeople(people: people, offsets: offsets)
                }
            }
        }
    }
    
    private func buildPredicate() -> NSPredicate? {
        var predicates: [NSPredicate] = []
        
        // Search text filter
        if !searchText.isEmpty {
            let searchPredicate = NSPredicate(
                format: "name CONTAINS[cd] %@ OR email CONTAINS[cd] %@",
                searchText, searchText
            )
            predicates.append(searchPredicate)
        }
        
        // Active status filter
        if showActiveOnly {
            let activePredicate = NSPredicate(format: "isActive == true")
            predicates.append(activePredicate)
        }
        
        // Combine predicates
        if predicates.isEmpty {
            return nil
        } else if predicates.count == 1 {
            return predicates.first
        } else {
            return NSCompoundPredicate(andPredicateWithSubpredicates: predicates)
        }
    }
    
    private func deletePeople(people: FetchedResults<Person>, offsets: IndexSet) {
        withAnimation {
            offsets.map { people[$0] }.forEach(context.delete)
            CoreDataManager.shared.save()
        }
    }
}

// === Dynamic FetchRequest Helper ===
struct DynamicFetchRequestView<Entity: NSManagedObject, Content: View>: View {
    let content: (FetchedResults<Entity>) -> Content
    
    @FetchRequest private var items: FetchedResults<Entity>
    
    init(
        predicate: NSPredicate? = nil,
        sortDescriptors: [NSSortDescriptor] = [],
        @ViewBuilder content: @escaping (FetchedResults<Entity>) -> Content
    ) {
        self.content = content
        
        let request = Entity.fetchRequest()
        request.predicate = predicate
        request.sortDescriptors = sortDescriptors
        
        self._items = FetchRequest(fetchRequest: request as! NSFetchRequest<Entity>)
    }
    
    var body: some View {
        content(items)
    }
}
</code></pre>
      </div>

      <h2 class="section-title">‚úèÔ∏è CRUD Operations</h2>

      <div class="warning-box">
        <h5>ÿ•ÿØÿßÿ±ÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™: Create, Read, Update, Delete</h5>
        <p>ÿ™ÿ∑ÿ®ŸäŸÇ ÿßŸÑÿπŸÖŸÑŸäÿßÿ™ ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿäÿ© ÿπŸÑŸâ ÿßŸÑŸÄ Core Data entities</p>
      </div>

      <div class="code-container">
        <pre><code class="language-swift">
// === Create/Edit Person View ===
struct PersonEditView: View {
    @Environment(\.managedObjectContext) private var context
    @Environment(\.dismiss) private var dismiss
    
    // Existing person for editing, nil for creating new
    let person: Person?
    
    @State private var name: String = ""
    @State private var email: String = ""
    @State private var age: String = ""
    @State private var isActive: Bool = true
    
    private var isEditing: Bool {
        person != nil
    }
    
    var body: some View {
        NavigationView {
            Form {
                Section("Personal Information") {
                    TextField("Name", text: $name)
                        .textContentType(.name)
                    
                    TextField("Email", text: $email)
                        .textContentType(.emailAddress)
                        .keyboardType(.emailAddress)
                    
                    TextField("Age", text: $age)
                        .keyboardType(.numberPad)
                }
                
                Section("Status") {
                    Toggle("Active", isOn: $isActive)
                }
                
                Section {
                    Button(isEditing ? "Update Person" : "Create Person") {
                        savePerson()
                    }
                    .disabled(!isValidInput)
                }
            }
            .navigationTitle(isEditing ? "Edit Person" : "New Person")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
            }
            .onAppear {
                loadPersonData()
            }
        }
    }
    
    private var isValidInput: Bool {
        !name.isEmpty && !email.isEmpty && Int(age) != nil
    }
    
    private func loadPersonData() {
        if let person = person {
            name = person.name ?? ""
            email = person.email ?? ""
            age = String(person.age)
            isActive = person.isActive
        }
    }
    
    private func savePerson() {
        guard let ageInt = Int(age) else { return }
        
        if let existingPerson = person {
            // Update existing person
            existingPerson.name = name
            existingPerson.email = email
            existingPerson.age = Int16(ageInt)
            existingPerson.isActive = isActive
        } else {
            // Create new person
            let newPerson = Person.create(
                in: context,
                name: name,
                email: email,
                age: Int16(ageInt)
            )
            newPerson.isActive = isActive
        }
        
        CoreDataManager.shared.save()
        dismiss()
    }
}

// === Advanced CRUD Operations ===
struct PersonManagementView: View {
    @FetchRequest(
        entity: Person.entity(),
        sortDescriptors: [NSSortDescriptor(keyPath: \Person.dateCreated, ascending: false)]
    ) var people: FetchedResults<Person>
    
    @Environment(\.managedObjectContext) private var context
    @EnvironmentObject private var coreDataManager: CoreDataManager
    
    @State private var showingAddPerson = false
    @State private var selectedPerson: Person?
    @State private var showingDeleteAlert = false
    @State private var personToDelete: Person?
    
    var body: some View {
        NavigationView {
            List {
                Section("Statistics") {
                    HStack {
                        Text("Total People:")
                        Spacer()
                        Text("\(people.count)")
                            .fontWeight(.bold)
                    }
                    
                    HStack {
                        Text("Active People:")
                        Spacer()
                        Text("\(activePeopleCount)")
                            .fontWeight(.bold)
                            .foregroundColor(.green)
                    }
                }
                
                Section("People") {
                    ForEach(people, id: \.objectID) { person in
                        PersonRowView(person: person)
                            .swipeActions(edge: .trailing) {
                                // Delete action
                                Button(role: .destructive) {
                                    personToDelete = person
                                    showingDeleteAlert = true
                                } label: {
                                    Label("Delete", systemImage: "trash")
                                }
                                
                                // Edit action
                                Button {
                                    selectedPerson = person
                                } label: {
                                    Label("Edit", systemImage: "pencil")
                                }
                                .tint(.blue)
                                
                                // Toggle active status
                                Button {
                                    togglePersonStatus(person)
                                } label: {
                                    Label(
                                        person.isActive ? "Deactivate" : "Activate",
                                        systemImage: person.isActive ? "pause.circle" : "play.circle"
                                    )
                                }
                                .tint(person.isActive ? .orange : .green)
                            }
                            .contextMenu {
                                Button("Edit") {
                                    selectedPerson = person
                                }
                                
                                Button("Duplicate") {
                                    duplicatePerson(person)
                                }
                                
                                Button("Toggle Status") {
                                    togglePersonStatus(person)
                                }
                                
                                Button("Delete", role: .destructive) {
                                    personToDelete = person
                                    showingDeleteAlert = true
                                }
                            }
                    }
                }
            }
            .navigationTitle("Person Management")
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Menu {
                        Button("Add Person") {
                            showingAddPerson = true
                        }
                        
                        Button("Add Sample Data") {
                            addSampleData()
                        }
                        
                        Button("Clear All Data", role: .destructive) {
                            clearAllData()
                        }
                    } label: {
                        Image(systemName: "plus")
                    }
                }
            }
            .sheet(isPresented: $showingAddPerson) {
                PersonEditView(person: nil)
            }
            .sheet(item: $selectedPerson) { person in
                PersonEditView(person: person)
            }
            .alert("Delete Person", isPresented: $showingDeleteAlert) {
                Button("Delete", role: .destructive) {
                    if let person = personToDelete {
                        deletePerson(person)
                    }
                }
                Button("Cancel", role: .cancel) { }
            } message: {
                Text("Are you sure you want to delete this person? This action cannot be undone.")
            }
        }
    }
    
    private var activePeopleCount: Int {
        people.filter { $0.isActive }.count
    }
    
    private func togglePersonStatus(_ person: Person) {
        withAnimation {
            person.isActive.toggle()
            coreDataManager.save()
        }
    }
    
    private func duplicatePerson(_ person: Person) {
        withAnimation {
            let duplicate = Person.create(
                in: context,
                name: "\(person.name ?? "Copy") (Copy)",
                email: person.email ?? "",
                age: person.age
            )
            duplicate.isActive = person.isActive
            
            coreDataManager.save()
        }
    }
    
    private func deletePerson(_ person: Person) {
        withAnimation {
            context.delete(person)
            coreDataManager.save()
        }
    }
    
    private func addSampleData() {
        let samplePeople = [
            ("Ahmed Ali", "ahmed@example.com", 28),
            ("Sara Mohamed", "sara@example.com", 32),
            ("Omar Hassan", "omar@example.com", 25),
            ("Fatma Ibrahim", "fatma@example.com", 29),
            ("Mahmoud Saeed", "mahmoud@example.com", 35)
        ]
        
        withAnimation {
            for (name, email, age) in samplePeople {
                Person.create(in: context, name: name, email: email, age: Int16(age))
            }
            coreDataManager.save()
        }
    }
    
    private func clearAllData() {
        withAnimation {
            for person in people {
                context.delete(person)
            }
            coreDataManager.save()
        }
    }
}
</code></pre>
      </div>

      <h2 class="section-title">üîÑ Background Operations</h2>

      <div class="success-box">
        <h5>Background Context ŸÑŸÑŸÄ Heavy Operations</h5>
        <p>ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ background contexts ŸÑŸÑÿπŸÖŸÑŸäÿßÿ™ ÿßŸÑÿ´ŸÇŸäŸÑÿ© ÿ®ÿØŸàŸÜ blocking ŸÑŸÑŸÄ UI</p>
      </div>

      <div class="code-container">
        <pre><code class="language-swift">
// === Background Operations Manager ===
class BackgroundOperationsManager: ObservableObject {
    private let coreDataManager = CoreDataManager.shared
    @Published var isImporting = false
    @Published var importProgress: Double = 0.0
    @Published var importStatus = ""
    
    // Import large dataset in background
    func importLargeDataset() {
        isImporting = true
        importProgress = 0.0
        importStatus = "Starting import..."
        
        // Create background context
        let backgroundContext = coreDataManager.backgroundContext()
        
        // Perform heavy operation in background
        backgroundContext.perform {
            let sampleData = self.generateLargeDataset()
            let totalItems = sampleData.count
            
            for (index, item) in sampleData.enumerated() {
                // Create person in background context
                let person = Person(context: backgroundContext)
                person.name = item.name
                person.email = item.email
                person.age = item.age
                person.dateCreated = Date()
                person.isActive = true
                
                // Update progress on main thread
                let progress = Double(index + 1) / Double(totalItems)
                DispatchQueue.main.async {
                    self.importProgress = progress
                    self.importStatus = "Imported \(index + 1) of \(totalItems) people"
                }
                
                // Save periodically to avoid memory issues
                if (index + 1) % 100 == 0 {
                    self.coreDataManager.saveBackground(context: backgroundContext)
                }
            }
            
            // Final save
            self.coreDataManager.saveBackground(context: backgroundContext)
            
            // Update UI on main thread
            DispatchQueue.main.async {
                self.isImporting = false
                self.importStatus = "Import completed successfully"
                
                // Clear status after delay
                DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
                    self.importStatus = ""
                }
            }
        }
    }
    
    // Bulk delete operation
    func performBulkDelete(predicate: NSPredicate) {
        let backgroundContext = coreDataManager.backgroundContext()
        
        backgroundContext.perform {
            let fetchRequest = NSFetchRequest<NSFetchRequestResult>(entityName: "Person")
            fetchRequest.predicate = predicate
            
            let deleteRequest = NSBatchDeleteRequest(fetchRequest: fetchRequest)
            deleteRequest.resultType = .resultTypeObjectIDs
            
            do {
                let result = try backgroundContext.execute(deleteRequest) as? NSBatchDeleteResult
                
                if let objectIDs = result?.result as? [NSManagedObjectID] {
                    // Merge changes to main context
                    let changes = [NSDeletedObjectsKey: objectIDs]
                    NSManagedObjectContext.mergeChanges(
                        fromRemoteContextSave: changes,
                        into: [self.coreDataManager.mainContext]
                    )
                    
                    print("‚úÖ Bulk delete completed for \(objectIDs.count) objects")
                }
            } catch {
                print("‚ùå Bulk delete failed: \(error)")
            }
        }
    }
    
    private func generateLargeDataset() -> [(name: String, email: String, age: Int16)] {
        let firstNames = ["Ahmed", "Sara", "Omar", "Fatma", "Mahmoud", "Nadia", "Karim", "Laila", "Hassan", "Mariam"]
        let lastNames = ["Ali", "Mohamed", "Hassan", "Ibrahim", "Saeed", "Farouk", "Abdel", "Khalil", "Nour", "Zaki"]
        
        return (1...1000).map { index in
            let firstName = firstNames[index % firstNames.count]
            let lastName = lastNames[(index / firstNames.count) % lastNames.count]
            let name = "\(firstName) \(lastName) \(index)"
            let email = "\(firstName.lowercased())\(index)@example.com"
            let age = Int16.random(in: 18...70)
            
            return (name: name, email: email, age: age)
        }
    }
}

// === Background Operations View ===
struct BackgroundOperationsView: View {
    @StateObject private var operationsManager = BackgroundOperationsManager()
    @Environment(\.managedObjectContext) private var context
    
    @FetchRequest(
        entity: Person.entity(),
        sortDescriptors: [NSSortDescriptor(keyPath: \Person.dateCreated, ascending: false)]
    ) var people: FetchedResults<Person>
    
    var body: some View {
        NavigationView {
            VStack(spacing: 20) {
                // Statistics
                VStack {
                    Text("Total People: \(people.count)")
                        .font(.title2)
                        .fontWeight(.bold)
                    
                    if !operationsManager.importStatus.isEmpty {
                        Text(operationsManager.importStatus)
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }
                .padding()
                .background(Color.gray.opacity(0.1))
                .cornerRadius(10)
                
                // Import Progress
                if operationsManager.isImporting {
                    VStack {
                        ProgressView(value: operationsManager.importProgress)
                            .progressViewStyle(LinearProgressViewStyle())
                        
                        Text("\(Int(operationsManager.importProgress * 100))% Complete")
                            .font(.caption)
                    }
                    .padding()
                }
                
                // Action Buttons
                VStack(spacing: 15) {
                    Button("Import 1000 People") {
                        operationsManager.importLargeDataset()
                    }
                    .disabled(operationsManager.isImporting)
                    .buttonStyle(.borderedProminent)
                    
                    Button("Delete Inactive People") {
                        let predicate = NSPredicate(format: "isActive == false")
                        operationsManager.performBulkDelete(predicate: predicate)
                    }
                    .disabled(operationsManager.isImporting)
                    .buttonStyle(.bordered)
                    
                    Button("Delete All People", role: .destructive) {
                        let predicate = NSPredicate(value: true) // All objects
                        operationsManager.performBulkDelete(predicate: predicate)
                    }
                    .disabled(operationsManager.isImporting)
                    .buttonStyle(.bordered)
                }
                
                Spacer()
                
                // Recent People List
                if !people.isEmpty {
                    Text("Recent People")
                        .font(.headline)
                    
                    List(people.prefix(10), id: \.objectID) { person in
                        PersonRowView(person: person)
                    }
                    .frame(maxHeight: 300)
                }
            }
            .padding()
            .navigationTitle("Background Operations")
        }
    }
}

// === Relationship Management ===
// Example of managing Core Data relationships in SwiftUI
struct CompanyPersonView: View {
    @FetchRequest(
        entity: Company.entity(),
        sortDescriptors: [NSSortDescriptor(keyPath: \Company.name, ascending: true)]
    ) var companies: FetchedResults<Company>
    
    @Environment(\.managedObjectContext) private var context
    
    var body: some View {
        NavigationView {
            List {
                ForEach(companies, id: \.objectID) { company in
                    Section(company.name ?? "Unknown Company") {
                        // Access relationship through Core Data
                        if let employees = company.employees?.allObjects as? [Person] {
                            ForEach(employees, id: \.objectID) { employee in
                                PersonRowView(person: employee)
                            }
                        } else {
                            Text("No employees")
                                .foregroundColor(.secondary)
                        }
                    }
                }
            }
            .navigationTitle("Companies & Employees")
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Add Sample Company") {
                        addSampleCompany()
                    }
                }
            }
        }
    }
    
    private func addSampleCompany() {
        withAnimation {
            // Create company
            let company = Company(context: context)
            company.name = "Tech Company \(Int.random(in: 1...100))"
            
            // Create employees
            for i in 1...3 {
                let employee = Person.create(
                    in: context,
                    name: "Employee \(i)",
                    email: "employee\(i)@company.com",
                    age: Int16.random(in: 25...50)
                )
                
                // Set relationship
                company.addToEmployees(employee)
            }
            
            CoreDataManager.shared.save()
        }
    }
}
</code></pre>
      </div>

      <h2 class="section-title">üéØ Best Practices</h2>

      <div class="highlight-box">
        <h4>ÿ£ŸÅÿ∂ŸÑ ÿßŸÑŸÖŸÖÿßÿ±ÿ≥ÿßÿ™ ŸÑŸÑŸÄ SwiftUI Core Data Integration:</h4>
        <ol>
          <li><strong>Use @FetchRequest:</strong> ŸÑŸÑŸÄ automatic UI updates</li>
          <li><strong>Background Contexts:</strong> ŸÑŸÑŸÄ heavy operations</li>
          <li><strong>Batch Operations:</strong> ŸÑŸÑŸÄ bulk changes</li>
          <li><strong>Proper Error Handling:</strong> ŸÖÿπ informative messages</li>
          <li><strong>Memory Management:</strong> save periodically ŸÅŸä ÿßŸÑŸÄ large operations</li>
          <li><strong>Merge Policies:</strong> ŸÑÿ≠ŸÑ ÿßŸÑŸÄ conflicts</li>
        </ol>
      </div>

      <h2 class="section-title">üìä ÿßŸÑÿÆŸÑÿßÿµÿ©</h2>

      <div class="concept-box">
        <p>
          <strong>SwiftUI Core Data Integration:</strong>
        </p>
        <ul>
          <li><strong>@FetchRequest:</strong> automatic data binding ŸÖÿπ Core Data</li>
          <li><strong>@Environment(\.managedObjectContext):</strong> ŸÑŸÑŸàÿµŸàŸÑ ŸÑŸÑŸÄ context</li>
          <li><strong>Background Operations:</strong> ŸÑŸÑŸÄ heavy data operations</li>
          <li><strong>Automatic Updates:</strong> ÿßŸÑŸÄ UI ÿ®Ÿäÿ™ÿ≠ÿØÿ´ ÿ™ŸÑŸÇÿßÿ¶ŸäÿßŸã ŸÖÿπ data changes</li>
          <li><strong>Relationship Management:</strong> direct access ŸÑŸÄ Core Data relationships</li>
          <li><strong>Performance:</strong> optimized ŸÑŸÑŸÄ large datasets</li>
        </ul>
      </div>

      <div class="mt-4">
        <a href="../SwiftUI_Interview_Questions.html" class="back-btn">
          ‚Üê ÿßŸÑÿπŸàÿØÿ© ŸÑŸÑÿ£ÿ≥ÿ¶ŸÑÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©
        </a>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/autoloader/prism-autoloader.min.js"></script>
  </body>
</html>