<!DOCTYPE html>
<html lang="ar" dir="rtl">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Scrolling in SwiftUI</title>
    
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-tomorrow.min.css" rel="stylesheet">
    
    <style>
      body {
        font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
        line-height: 1.6;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        direction: rtl;
      }
      .container {
        background: white;
        border-radius: 15px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        margin: 2rem auto;
        padding: 2rem;
        max-width: 1200px;
      }
      .question-title {
        color: #2c3e50;
        border-bottom: 3px solid #3498db;
        padding-bottom: 1rem;
        margin-bottom: 2rem;
        font-weight: 700;
      }
      .section-title {
        color: #e74c3c;
        margin: 2rem 0 1rem 0;
        font-weight: 600;
        font-size: 1.3rem;
      }
      .code-container {
        background: #2d3748;
        border-radius: 10px;
        padding: 1.5rem;
        margin: 1rem 0;
        overflow-x: auto;
      }
      .code-container code {
        color: #e2e8f0;
        font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
      }
      .highlight-box {
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
        padding: 1.5rem;
        border-radius: 10px;
        margin: 1.5rem 0;
      }
      .back-btn {
        background: linear-gradient(135deg, #667eea, #764ba2);
        border: none;
        color: white;
        padding: 0.7rem 1.5rem;
        border-radius: 25px;
        font-weight: 600;
        transition: transform 0.3s ease;
        text-decoration: none;
        display: inline-block;
        margin-bottom: 2rem;
      }
      .back-btn:hover {
        transform: translateY(-2px);
        color: white;
      }
      .concept-box {
        background: #f8f9fa;
        border-left: 4px solid #3498db;
        padding: 1rem 1.5rem;
        margin: 1rem 0;
        border-radius: 0 8px 8px 0;
      }
      .warning-box {
        background: #fff3cd;
        border-left: 4px solid #ffc107;
        padding: 1rem 1.5rem;
        margin: 1rem 0;
        border-radius: 0 8px 8px 0;
      }
      .success-box {
        background: #d1edff;
        border-left: 4px solid #17a2b8;
        padding: 1rem 1.5rem;
        margin: 1rem 0;
        border-radius: 0 8px 8px 0;
      }
    </style>
  </head>

  <body>
    <div class="container">
      <a href="../SwiftUI_Interview_Questions.html" class="back-btn">
        ← العودة للصفحة الرئيسية
      </a>

      <h1 class="question-title">
        How to implement infinite scrolling in SwiftUI?
      </h1>

      <div class="highlight-box">
        <h4>🔄 الفكرة الأساسية</h4>
        <p>
          <strong>Infinite Scrolling</strong> أو Pagination في SwiftUI بيتم عن طريق detecting لما المستخدم يوصل 
          لآخر عنصر في الـ List وتحميل المزيد من البيانات automatically.
        </p>
      </div>

      <h2 class="section-title">📝 الشرح بالعربي</h2>
      <p>
        Infinite Scrolling مهم جداً في أي تطبيق بيعرض قوائم كبيرة من البيانات. 
        بدل ما نحمل كل البيانات مرة واحدة، بنحمل جزء صغير ولما المستخدم يوصل لآخره 
        نجيب المزيد. ده بيحسن performance ويقلل استهلاك الذاكرة.
      </p>

      <h2 class="section-title">🎯 Basic Infinite Scrolling Implementation</h2>

      <div class="success-box">
        <h5>1. Simple Pagination with onAppear</h5>
        <p>الطريقة الأساسية باستخدام onAppear على آخر عنصر</p>
      </div>

      <div class="code-container">
        <pre><code class="language-swift">
@MainActor
class InfiniteScrollViewModel: ObservableObject {
    @Published var items: [Item] = []
    @Published var isLoading = false
    @Published var hasMoreData = true
    
    private var currentPage = 1
    private let pageSize = 20
    
    func loadInitialData() async {
        currentPage = 1
        hasMoreData = true
        await loadMoreData()
    }
    
    func loadMoreData() async {
        guard !isLoading && hasMoreData else { return }
        
        isLoading = true
        
        do {
            let newItems = try await APIService.shared.fetchItems(
                page: currentPage,
                pageSize: pageSize
            )
            
            if newItems.count < pageSize {
                hasMoreData = false
            }
            
            if currentPage == 1 {
                items = newItems
            } else {
                items.append(contentsOf: newItems)
            }
            
            currentPage += 1
            
        } catch {
            print("Error loading data: \(error)")
        }
        
        isLoading = false
    }
}

struct InfiniteScrollListView: View {
    @StateObject private var viewModel = InfiniteScrollViewModel()
    
    var body: some View {
        NavigationView {
            List {
                ForEach(viewModel.items) { item in
                    ItemRowView(item: item)
                        .onAppear {
                            // Load more when we reach the last item
                            if item.id == viewModel.items.last?.id {
                                Task {
                                    await viewModel.loadMoreData()
                                }
                            }
                        }
                }
                
                if viewModel.isLoading {
                    HStack {
                        Spacer()
                        ProgressView()
                        Spacer()
                    }
                }
            }
            .navigationTitle("Infinite Scroll")
            .task {
                await viewModel.loadInitialData()
            }
            .refreshable {
                await viewModel.loadInitialData()
            }
        }
    }
}
</code></pre>
      </div>

      <h2 class="section-title">⚡ Advanced Implementation with Threshold</h2>

      <div class="concept-box">
        <h5>Loading with Threshold</h5>
        <p>بدل ما نستنى المستخدم يوصل لآخر عنصر، نحمل البيانات قبلها بعناصر قليلة</p>
      </div>

      <div class="code-container">
        <pre><code class="language-swift">
@MainActor
class ThresholdPaginationViewModel: ObservableObject {
    @Published var items: [Item] = []
    @Published var isLoading = false
    @Published var loadingError: String?
    @Published var hasMoreData = true
    
    private var currentPage = 1
    private let pageSize = 20
    private let threshold = 5 // Load more when 5 items from bottom
    
    func loadMoreIfNeeded(for item: Item) async {
        guard let itemIndex = items.firstIndex(where: { $0.id == item.id }) else {
            return
        }
        
        let thresholdIndex = items.count - threshold
        
        if itemIndex >= thresholdIndex {
            await loadMoreData()
        }
    }
    
    func loadMoreData() async {
        guard !isLoading && hasMoreData else { return }
        
        isLoading = true
        loadingError = nil
        
        do {
            let newItems = try await APIService.shared.fetchItems(
                page: currentPage,
                pageSize: pageSize
            )
            
            // Check if we've reached the end
            if newItems.count < pageSize {
                hasMoreData = false
            }
            
            // Avoid duplicates (في حالة multiple requests)
            let uniqueNewItems = newItems.filter { newItem in
                !items.contains { $0.id == newItem.id }
            }
            
            items.append(contentsOf: uniqueNewItems)
            currentPage += 1
            
        } catch {
            loadingError = error.localizedDescription
            print("Error loading more data: \(error)")
        }
        
        isLoading = false
    }
    
    func refresh() async {
        currentPage = 1
        hasMoreData = true
        items.removeAll()
        await loadMoreData()
    }
}

struct ThresholdListView: View {
    @StateObject private var viewModel = ThresholdPaginationViewModel()
    
    var body: some View {
        NavigationView {
            VStack {
                if let error = viewModel.loadingError {
                    ErrorBanner(message: error) {
                        Task {
                            await viewModel.loadMoreData()
                        }
                    }
                }
                
                List {
                    ForEach(viewModel.items) { item in
                        ItemRowView(item: item)
                            .onAppear {
                                Task {
                                    await viewModel.loadMoreIfNeeded(for: item)
                                }
                            }
                    }
                    
                    if viewModel.isLoading {
                        LoadingRowView()
                    } else if !viewModel.hasMoreData && !viewModel.items.isEmpty {
                        Text("No more items")
                            .foregroundColor(.secondary)
                            .frame(maxWidth: .infinity)
                            .padding()
                    }
                }
                .listStyle(PlainListStyle())
            }
            .navigationTitle("Smart Pagination")
            .task {
                if viewModel.items.isEmpty {
                    await viewModel.loadMoreData()
                }
            }
            .refreshable {
                await viewModel.refresh()
            }
        }
    }
}

struct ErrorBanner: View {
    let message: String
    let onRetry: () -> Void
    
    var body: some View {
        HStack {
            Image(systemName: "exclamationmark.triangle")
            Text(message)
            Spacer()
            Button("Retry", action: onRetry)
        }
        .padding()
        .background(Color.red.opacity(0.1))
        .foregroundColor(.red)
    }
}

struct LoadingRowView: View {
    var body: some View {
        HStack {
            Spacer()
            ProgressView()
                .scaleEffect(0.8)
            Text("Loading more...")
                .font(.caption)
                .foregroundColor(.secondary)
            Spacer()
        }
        .padding()
    }
}
</code></pre>
      </div>

      <h2 class="section-title">🔍 Search with Infinite Scroll</h2>

      <div class="warning-box">
        <h5>تطبيق Infinite Scrolling مع Search</h5>
        <p>دمج البحث مع الـ pagination لتجربة مستخدم أفضل</p>
      </div>

      <div class="code-container">
        <pre><code class="language-swift">
@MainActor
class SearchPaginationViewModel: ObservableObject {
    @Published var items: [Item] = []
    @Published var searchText = ""
    @Published var isLoading = false
    @Published var isSearching = false
    @Published var hasMoreData = true
    
    private var currentPage = 1
    private let pageSize = 20
    private var searchTask: Task<Void, Never>?
    
    init() {
        setupSearch()
    }
    
    private func setupSearch() {
        // Debounce search to avoid too many API calls
        $searchText
            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)
            .removeDuplicates()
            .sink { [weak self] searchText in
                Task { @MainActor in
                    await self?.performSearch(searchText)
                }
            }
            .store(in: &cancellables)
    }
    
    private var cancellables = Set<AnyCancellable>()
    
    func performSearch(_ query: String) async {
        // Cancel previous search
        searchTask?.cancel()
        
        searchTask = Task {
            isSearching = true
            currentPage = 1
            hasMoreData = true
            
            do {
                let searchResults = try await APIService.shared.searchItems(
                    query: query,
                    page: currentPage,
                    pageSize: pageSize
                )
                
                if !Task.isCancelled {
                    items = searchResults
                    currentPage += 1
                    
                    if searchResults.count < pageSize {
                        hasMoreData = false
                    }
                }
                
            } catch {
                if !Task.isCancelled {
                    print("Search error: \(error)")
                }
            }
            
            isSearching = false
        }
    }
    
    func loadMoreSearchResults() async {
        guard !isLoading && !isSearching && hasMoreData else { return }
        
        isLoading = true
        
        do {
            let moreResults = try await APIService.shared.searchItems(
                query: searchText,
                page: currentPage,
                pageSize: pageSize
            )
            
            items.append(contentsOf: moreResults)
            currentPage += 1
            
            if moreResults.count < pageSize {
                hasMoreData = false
            }
            
        } catch {
            print("Error loading more search results: \(error)")
        }
        
        isLoading = false
    }
}

struct SearchableInfiniteListView: View {
    @StateObject private var viewModel = SearchPaginationViewModel()
    
    var body: some View {
        NavigationView {
            VStack {
                SearchBar(text: $viewModel.searchText)
                
                if viewModel.isSearching {
                    HStack {
                        ProgressView()
                        Text("Searching...")
                    }
                    .padding()
                }
                
                List {
                    ForEach(viewModel.items) { item in
                        ItemRowView(item: item)
                            .onAppear {
                                if item.id == viewModel.items.last?.id {
                                    Task {
                                        await viewModel.loadMoreSearchResults()
                                    }
                                }
                            }
                    }
                    
                    if viewModel.isLoading {
                        LoadingRowView()
                    }
                }
            }
            .navigationTitle("Search & Scroll")
        }
    }
}

struct SearchBar: View {
    @Binding var text: String
    
    var body: some View {
        HStack {
            Image(systemName: "magnifyingglass")
                .foregroundColor(.secondary)
            
            TextField("Search items...", text: $text)
                .textFieldStyle(RoundedBorderTextFieldStyle())
            
            if !text.isEmpty {
                Button("Clear") {
                    text = ""
                }
                .foregroundColor(.secondary)
            }
        }
        .padding(.horizontal)
    }
}
</code></pre>
      </div>

      <h2 class="section-title">🎛️ Grid-based Infinite Scrolling</h2>

      <div class="success-box">
        <h5>LazyVGrid مع Pagination</h5>
        <p>تطبيق infinite scrolling مع Grid layout</p>
      </div>

      <div class="code-container">
        <pre><code class="language-swift">
struct InfiniteGridView: View {
    @StateObject private var viewModel = GridPaginationViewModel()
    
    private let columns = [
        GridItem(.flexible()),
        GridItem(.flexible())
    ]
    
    var body: some View {
        NavigationView {
            ScrollView {
                LazyVGrid(columns: columns, spacing: 16) {
                    ForEach(viewModel.items) { item in
                        GridItemView(item: item)
                            .onAppear {
                                Task {
                                    await viewModel.loadMoreIfNeeded(for: item)
                                }
                            }
                    }
                    
                    if viewModel.isLoading {
                        GridLoadingView()
                    }
                }
                .padding()
            }
            .navigationTitle("Grid Pagination")
            .task {
                await viewModel.loadInitialData()
            }
            .refreshable {
                await viewModel.refresh()
            }
        }
    }
}

struct GridItemView: View {
    let item: Item
    
    var body: some View {
        VStack {
            AsyncImage(url: URL(string: item.imageURL)) { image in
                image
                    .resizable()
                    .aspectRatio(contentMode: .fill)
            } placeholder: {
                Rectangle()
                    .fill(Color.gray.opacity(0.3))
            }
            .frame(height: 120)
            .clipped()
            .cornerRadius(8)
            
            Text(item.title)
                .font(.caption)
                .lineLimit(2)
        }
        .frame(maxWidth: .infinity)
        .background(Color(.systemBackground))
        .cornerRadius(12)
        .shadow(radius: 2)
    }
}

struct GridLoadingView: View {
    var body: some View {
        HStack {
            Spacer()
            VStack {
                ProgressView()
                Text("Loading more...")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            Spacer()
        }
        .frame(height: 60)
        .gridCellColumns(2) // Takes full width in grid
    }
}

@MainActor
class GridPaginationViewModel: ObservableObject {
    @Published var items: [Item] = []
    @Published var isLoading = false
    @Published var hasMoreData = true
    
    private var currentPage = 1
    private let pageSize = 30 // Larger page size for grid
    private let threshold = 6 // Load when 6 items from bottom
    
    func loadMoreIfNeeded(for item: Item) async {
        guard let itemIndex = items.firstIndex(where: { $0.id == item.id }) else {
            return
        }
        
        let thresholdIndex = items.count - threshold
        
        if itemIndex >= thresholdIndex {
            await loadMoreData()
        }
    }
    
    func loadMoreData() async {
        guard !isLoading && hasMoreData else { return }
        
        isLoading = true
        
        do {
            let newItems = try await APIService.shared.fetchItems(
                page: currentPage,
                pageSize: pageSize
            )
            
            if newItems.count < pageSize {
                hasMoreData = false
            }
            
            items.append(contentsOf: newItems)
            currentPage += 1
            
        } catch {
            print("Error loading grid data: \(error)")
        }
        
        isLoading = false
    }
    
    func loadInitialData() async {
        currentPage = 1
        hasMoreData = true
        await loadMoreData()
    }
    
    func refresh() async {
        currentPage = 1
        hasMoreData = true
        items.removeAll()
        await loadMoreData()
    }
}
</code></pre>
      </div>

      <h2 class="section-title">🎯 Performance Optimizations</h2>

      <div class="highlight-box">
        <h4>تحسينات الأداء:</h4>
        <ol>
          <li><strong>LazyVStack/LazyHStack:</strong> للقوائم الطويلة</li>
          <li><strong>Task Cancellation:</strong> إلغاء الطلبات المكررة</li>
          <li><strong>Debouncing:</strong> تأخير البحث لتجنب كثرة الطلبات</li>
          <li><strong>Caching:</strong> حفظ البيانات المحملة</li>
          <li><strong>Image Loading:</strong> استخدام AsyncImage مع caching</li>
          <li><strong>Memory Management:</strong> تنظيف البيانات القديمة عند الحاجة</li>
        </ol>
      </div>

      <div class="concept-box">
        <h5>Optimized ViewModel with Caching</h5>
      </div>

      <div class="code-container">
        <pre><code class="language-swift">
@MainActor
class OptimizedPaginationViewModel: ObservableObject {
    @Published var items: [Item] = []
    @Published var isLoading = false
    @Published var hasMoreData = true
    
    private var currentPage = 1
    private let pageSize = 20
    private var cache = NSCache<NSString, NSArray>()
    private var loadingTask: Task<Void, Never>?
    
    func loadMoreData() async {
        guard !isLoading && hasMoreData else { return }
        
        // Cancel previous loading task
        loadingTask?.cancel()
        
        loadingTask = Task {
            isLoading = true
            
            defer {
                isLoading = false
            }
            
            // Check cache first
            let cacheKey = "page_\(currentPage)" as NSString
            if let cachedItems = cache.object(forKey: cacheKey) as? [Item] {
                if !Task.isCancelled {
                    items.append(contentsOf: cachedItems)
                    currentPage += 1
                }
                return
            }
            
            do {
                let newItems = try await APIService.shared.fetchItems(
                    page: currentPage,
                    pageSize: pageSize
                )
                
                if !Task.isCancelled {
                    // Cache the results
                    cache.setObject(newItems as NSArray, forKey: cacheKey)
                    
                    items.append(contentsOf: newItems)
                    currentPage += 1
                    
                    if newItems.count < pageSize {
                        hasMoreData = false
                    }
                }
                
            } catch {
                if !Task.isCancelled {
                    print("Error loading data: \(error)")
                }
            }
        }
    }
    
    deinit {
        loadingTask?.cancel()
    }
}
</code></pre>
      </div>

      <h2 class="section-title">📊 الخلاصة</h2>

      <div class="concept-box">
        <p>
          <strong>Infinite Scrolling في SwiftUI:</strong>
        </p>
        <ul>
          <li><strong>onAppear detection:</strong> على آخر عناصر للتحميل</li>
          <li><strong>Threshold loading:</strong> تحميل البيانات قبل الوصول للنهاية</li>
          <li><strong>Error handling:</strong> التعامل مع الأخطاء بطريقة مناسبة</li>
          <li><strong>Search integration:</strong> دمج البحث مع الـ pagination</li>
          <li><strong>Performance optimization:</strong> استخدام LazyViews وcaching</li>
          <li><strong>Task management:</strong> إلغاء الطلبات المكررة</li>
        </ul>
      </div>

      <div class="mt-4">
        <a href="../SwiftUI_Interview_Questions.html" class="back-btn">
          ← العودة للأسئلة الرئيسية
        </a>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/autoloader/prism-autoloader.min.js"></script>
  </body>
</html>