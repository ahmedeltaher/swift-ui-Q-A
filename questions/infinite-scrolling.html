<!DOCTYPE html>
<html lang="ar" dir="rtl">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Scrolling in SwiftUI</title>
    
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-tomorrow.min.css" rel="stylesheet">
    
    <style>
      body {
        font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
        line-height: 1.6;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        direction: rtl;
      }
      .container {
        background: white;
        border-radius: 15px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        margin: 2rem auto;
        padding: 2rem;
        max-width: 1200px;
      }
      .question-title {
        color: #2c3e50;
        border-bottom: 3px solid #3498db;
        padding-bottom: 1rem;
        margin-bottom: 2rem;
        font-weight: 700;
      }
      .section-title {
        color: #e74c3c;
        margin: 2rem 0 1rem 0;
        font-weight: 600;
        font-size: 1.3rem;
      }
      .code-container {
        background: #2d3748;
        border-radius: 10px;
        padding: 1.5rem;
        margin: 1rem 0;
        overflow-x: auto;
      }
      .code-container code {
        color: #e2e8f0;
        font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
      }
      .highlight-box {
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
        padding: 1.5rem;
        border-radius: 10px;
        margin: 1.5rem 0;
      }
      .back-btn {
        background: linear-gradient(135deg, #667eea, #764ba2);
        border: none;
        color: white;
        padding: 0.7rem 1.5rem;
        border-radius: 25px;
        font-weight: 600;
        transition: transform 0.3s ease;
        text-decoration: none;
        display: inline-block;
        margin-bottom: 2rem;
      }
      .back-btn:hover {
        transform: translateY(-2px);
        color: white;
      }
      .concept-box {
        background: #f8f9fa;
        border-left: 4px solid #3498db;
        padding: 1rem 1.5rem;
        margin: 1rem 0;
        border-radius: 0 8px 8px 0;
      }
      .warning-box {
        background: #fff3cd;
        border-left: 4px solid #ffc107;
        padding: 1rem 1.5rem;
        margin: 1rem 0;
        border-radius: 0 8px 8px 0;
      }
      .success-box {
        background: #d1edff;
        border-left: 4px solid #17a2b8;
        padding: 1rem 1.5rem;
        margin: 1rem 0;
        border-radius: 0 8px 8px 0;
      }
    </style>
  </head>

  <body>
    <div class="container">
      <a href="../SwiftUI_Interview_Questions.html" class="back-btn">
        â† Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„ØµÙØ­Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
      </a>

      <h1 class="question-title">
        How to implement infinite scrolling in SwiftUI?
      </h1>

      <div class="highlight-box">
        <h4>ğŸ”„ Ø§Ù„ÙÙƒØ±Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©</h4>
        <p>
          <strong>Infinite Scrolling</strong> Ø£Ùˆ Pagination ÙÙŠ SwiftUI Ø¨ÙŠØªÙ… Ø¹Ù† Ø·Ø±ÙŠÙ‚ detecting Ù„Ù…Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙŠÙˆØµÙ„ 
          Ù„Ø¢Ø®Ø± Ø¹Ù†ØµØ± ÙÙŠ Ø§Ù„Ù€ List ÙˆØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª automatically.
        </p>
      </div>

      <h2 class="section-title">ğŸ“ Ø§Ù„Ø´Ø±Ø­ Ø¨Ø§Ù„Ø¹Ø±Ø¨ÙŠ</h2>
      <p>
        Infinite Scrolling Ù…Ù‡Ù… Ø¬Ø¯Ø§Ù‹ ÙÙŠ Ø£ÙŠ ØªØ·Ø¨ÙŠÙ‚ Ø¨ÙŠØ¹Ø±Ø¶ Ù‚ÙˆØ§Ø¦Ù… ÙƒØ¨ÙŠØ±Ø© Ù…Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª. 
        Ø¨Ø¯Ù„ Ù…Ø§ Ù†Ø­Ù…Ù„ ÙƒÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø©ØŒ Ø¨Ù†Ø­Ù…Ù„ Ø¬Ø²Ø¡ ØµØºÙŠØ± ÙˆÙ„Ù…Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙŠÙˆØµÙ„ Ù„Ø¢Ø®Ø±Ù‡ 
        Ù†Ø¬ÙŠØ¨ Ø§Ù„Ù…Ø²ÙŠØ¯. Ø¯Ù‡ Ø¨ÙŠØ­Ø³Ù† performance ÙˆÙŠÙ‚Ù„Ù„ Ø§Ø³ØªÙ‡Ù„Ø§Ùƒ Ø§Ù„Ø°Ø§ÙƒØ±Ø©.
      </p>

      <h2 class="section-title">ğŸ¯ Basic Infinite Scrolling Implementation</h2>

      <div class="success-box">
        <h5>1. Simple Pagination with onAppear</h5>
        <p>Ø§Ù„Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… onAppear Ø¹Ù„Ù‰ Ø¢Ø®Ø± Ø¹Ù†ØµØ±</p>
      </div>

      <div class="code-container">
        <pre><code class="language-swift">
@MainActor
class InfiniteScrollViewModel: ObservableObject {
    @Published var items: [Item] = []
    @Published var isLoading = false
    @Published var hasMoreData = true
    
    private var currentPage = 1
    private let pageSize = 20
    
    func loadInitialData() async {
        currentPage = 1
        hasMoreData = true
        await loadMoreData()
    }
    
    func loadMoreData() async {
        guard !isLoading && hasMoreData else { return }
        
        isLoading = true
        
        do {
            let newItems = try await APIService.shared.fetchItems(
                page: currentPage,
                pageSize: pageSize
            )
            
            if newItems.count < pageSize {
                hasMoreData = false
            }
            
            if currentPage == 1 {
                items = newItems
            } else {
                items.append(contentsOf: newItems)
            }
            
            currentPage += 1
            
        } catch {
            print("Error loading data: \(error)")
        }
        
        isLoading = false
    }
}

struct InfiniteScrollListView: View {
    @StateObject private var viewModel = InfiniteScrollViewModel()
    
    var body: some View {
        NavigationView {
            List {
                ForEach(viewModel.items) { item in
                    ItemRowView(item: item)
                        .onAppear {
                            // Load more when we reach the last item
                            if item.id == viewModel.items.last?.id {
                                Task {
                                    await viewModel.loadMoreData()
                                }
                            }
                        }
                }
                
                if viewModel.isLoading {
                    HStack {
                        Spacer()
                        ProgressView()
                        Spacer()
                    }
                }
            }
            .navigationTitle("Infinite Scroll")
            .task {
                await viewModel.loadInitialData()
            }
            .refreshable {
                await viewModel.loadInitialData()
            }
        }
    }
}
</code></pre>
      </div>

      <h2 class="section-title">âš¡ Advanced Implementation with Threshold</h2>

      <div class="concept-box">
        <h5>Loading with Threshold</h5>
        <p>Ø¨Ø¯Ù„ Ù…Ø§ Ù†Ø³ØªÙ†Ù‰ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙŠÙˆØµÙ„ Ù„Ø¢Ø®Ø± Ø¹Ù†ØµØ±ØŒ Ù†Ø­Ù…Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù‚Ø¨Ù„Ù‡Ø§ Ø¨Ø¹Ù†Ø§ØµØ± Ù‚Ù„ÙŠÙ„Ø©</p>
      </div>

      <div class="code-container">
        <pre><code class="language-swift">
@MainActor
class ThresholdPaginationViewModel: ObservableObject {
    @Published var items: [Item] = []
    @Published var isLoading = false
    @Published var loadingError: String?
    @Published var hasMoreData = true
    
    private var currentPage = 1
    private let pageSize = 20
    private let threshold = 5 // Load more when 5 items from bottom
    
    func loadMoreIfNeeded(for item: Item) async {
        guard let itemIndex = items.firstIndex(where: { $0.id == item.id }) else {
            return
        }
        
        let thresholdIndex = items.count - threshold
        
        if itemIndex >= thresholdIndex {
            await loadMoreData()
        }
    }
    
    func loadMoreData() async {
        guard !isLoading && hasMoreData else { return }
        
        isLoading = true
        loadingError = nil
        
        do {
            let newItems = try await APIService.shared.fetchItems(
                page: currentPage,
                pageSize: pageSize
            )
            
            // Check if we've reached the end
            if newItems.count < pageSize {
                hasMoreData = false
            }
            
            // Avoid duplicates (ÙÙŠ Ø­Ø§Ù„Ø© multiple requests)
            let uniqueNewItems = newItems.filter { newItem in
                !items.contains { $0.id == newItem.id }
            }
            
            items.append(contentsOf: uniqueNewItems)
            currentPage += 1
            
        } catch {
            loadingError = error.localizedDescription
            print("Error loading more data: \(error)")
        }
        
        isLoading = false
    }
    
    func refresh() async {
        currentPage = 1
        hasMoreData = true
        items.removeAll()
        await loadMoreData()
    }
}

struct ThresholdListView: View {
    @StateObject private var viewModel = ThresholdPaginationViewModel()
    
    var body: some View {
        NavigationView {
            VStack {
                if let error = viewModel.loadingError {
                    ErrorBanner(message: error) {
                        Task {
                            await viewModel.loadMoreData()
                        }
                    }
                }
                
                List {
                    ForEach(viewModel.items) { item in
                        ItemRowView(item: item)
                            .onAppear {
                                Task {
                                    await viewModel.loadMoreIfNeeded(for: item)
                                }
                            }
                    }
                    
                    if viewModel.isLoading {
                        LoadingRowView()
                    } else if !viewModel.hasMoreData && !viewModel.items.isEmpty {
                        Text("No more items")
                            .foregroundColor(.secondary)
                            .frame(maxWidth: .infinity)
                            .padding()
                    }
                }
                .listStyle(PlainListStyle())
            }
            .navigationTitle("Smart Pagination")
            .task {
                if viewModel.items.isEmpty {
                    await viewModel.loadMoreData()
                }
            }
            .refreshable {
                await viewModel.refresh()
            }
        }
    }
}

struct ErrorBanner: View {
    let message: String
    let onRetry: () -> Void
    
    var body: some View {
        HStack {
            Image(systemName: "exclamationmark.triangle")
            Text(message)
            Spacer()
            Button("Retry", action: onRetry)
        }
        .padding()
        .background(Color.red.opacity(0.1))
        .foregroundColor(.red)
    }
}

struct LoadingRowView: View {
    var body: some View {
        HStack {
            Spacer()
            ProgressView()
                .scaleEffect(0.8)
            Text("Loading more...")
                .font(.caption)
                .foregroundColor(.secondary)
            Spacer()
        }
        .padding()
    }
}
</code></pre>
      </div>

      <h2 class="section-title">ğŸ” Search with Infinite Scroll</h2>

      <div class="warning-box">
        <h5>ØªØ·Ø¨ÙŠÙ‚ Infinite Scrolling Ù…Ø¹ Search</h5>
        <p>Ø¯Ù…Ø¬ Ø§Ù„Ø¨Ø­Ø« Ù…Ø¹ Ø§Ù„Ù€ pagination Ù„ØªØ¬Ø±Ø¨Ø© Ù…Ø³ØªØ®Ø¯Ù… Ø£ÙØ¶Ù„</p>
      </div>

      <div class="code-container">
        <pre><code class="language-swift">
@MainActor
class SearchPaginationViewModel: ObservableObject {
    @Published var items: [Item] = []
    @Published var searchText = ""
    @Published var isLoading = false
    @Published var isSearching = false
    @Published var hasMoreData = true
    
    private var currentPage = 1
    private let pageSize = 20
    private var searchTask: Task<Void, Never>?
    
    init() {
        setupSearch()
    }
    
    private func setupSearch() {
        // Debounce search to avoid too many API calls
        $searchText
            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)
            .removeDuplicates()
            .sink { [weak self] searchText in
                Task { @MainActor in
                    await self?.performSearch(searchText)
                }
            }
            .store(in: &cancellables)
    }
    
    private var cancellables = Set<AnyCancellable>()
    
    func performSearch(_ query: String) async {
        // Cancel previous search
        searchTask?.cancel()
        
        searchTask = Task {
            isSearching = true
            currentPage = 1
            hasMoreData = true
            
            do {
                let searchResults = try await APIService.shared.searchItems(
                    query: query,
                    page: currentPage,
                    pageSize: pageSize
                )
                
                if !Task.isCancelled {
                    items = searchResults
                    currentPage += 1
                    
                    if searchResults.count < pageSize {
                        hasMoreData = false
                    }
                }
                
            } catch {
                if !Task.isCancelled {
                    print("Search error: \(error)")
                }
            }
            
            isSearching = false
        }
    }
    
    func loadMoreSearchResults() async {
        guard !isLoading && !isSearching && hasMoreData else { return }
        
        isLoading = true
        
        do {
            let moreResults = try await APIService.shared.searchItems(
                query: searchText,
                page: currentPage,
                pageSize: pageSize
            )
            
            items.append(contentsOf: moreResults)
            currentPage += 1
            
            if moreResults.count < pageSize {
                hasMoreData = false
            }
            
        } catch {
            print("Error loading more search results: \(error)")
        }
        
        isLoading = false
    }
}

struct SearchableInfiniteListView: View {
    @StateObject private var viewModel = SearchPaginationViewModel()
    
    var body: some View {
        NavigationView {
            VStack {
                SearchBar(text: $viewModel.searchText)
                
                if viewModel.isSearching {
                    HStack {
                        ProgressView()
                        Text("Searching...")
                    }
                    .padding()
                }
                
                List {
                    ForEach(viewModel.items) { item in
                        ItemRowView(item: item)
                            .onAppear {
                                if item.id == viewModel.items.last?.id {
                                    Task {
                                        await viewModel.loadMoreSearchResults()
                                    }
                                }
                            }
                    }
                    
                    if viewModel.isLoading {
                        LoadingRowView()
                    }
                }
            }
            .navigationTitle("Search & Scroll")
        }
    }
}

struct SearchBar: View {
    @Binding var text: String
    
    var body: some View {
        HStack {
            Image(systemName: "magnifyingglass")
                .foregroundColor(.secondary)
            
            TextField("Search items...", text: $text)
                .textFieldStyle(RoundedBorderTextFieldStyle())
            
            if !text.isEmpty {
                Button("Clear") {
                    text = ""
                }
                .foregroundColor(.secondary)
            }
        }
        .padding(.horizontal)
    }
}
</code></pre>
      </div>

      <h2 class="section-title">ğŸ›ï¸ Grid-based Infinite Scrolling</h2>

      <div class="success-box">
        <h5>LazyVGrid Ù…Ø¹ Pagination</h5>
        <p>ØªØ·Ø¨ÙŠÙ‚ infinite scrolling Ù…Ø¹ Grid layout</p>
      </div>

      <div class="code-container">
        <pre><code class="language-swift">
struct InfiniteGridView: View {
    @StateObject private var viewModel = GridPaginationViewModel()
    
    private let columns = [
        GridItem(.flexible()),
        GridItem(.flexible())
    ]
    
    var body: some View {
        NavigationView {
            ScrollView {
                LazyVGrid(columns: columns, spacing: 16) {
                    ForEach(viewModel.items) { item in
                        GridItemView(item: item)
                            .onAppear {
                                Task {
                                    await viewModel.loadMoreIfNeeded(for: item)
                                }
                            }
                    }
                    
                    if viewModel.isLoading {
                        GridLoadingView()
                    }
                }
                .padding()
            }
            .navigationTitle("Grid Pagination")
            .task {
                await viewModel.loadInitialData()
            }
            .refreshable {
                await viewModel.refresh()
            }
        }
    }
}

struct GridItemView: View {
    let item: Item
    
    var body: some View {
        VStack {
            AsyncImage(url: URL(string: item.imageURL)) { image in
                image
                    .resizable()
                    .aspectRatio(contentMode: .fill)
            } placeholder: {
                Rectangle()
                    .fill(Color.gray.opacity(0.3))
            }
            .frame(height: 120)
            .clipped()
            .cornerRadius(8)
            
            Text(item.title)
                .font(.caption)
                .lineLimit(2)
        }
        .frame(maxWidth: .infinity)
        .background(Color(.systemBackground))
        .cornerRadius(12)
        .shadow(radius: 2)
    }
}

struct GridLoadingView: View {
    var body: some View {
        HStack {
            Spacer()
            VStack {
                ProgressView()
                Text("Loading more...")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            Spacer()
        }
        .frame(height: 60)
        .gridCellColumns(2) // Takes full width in grid
    }
}

@MainActor
class GridPaginationViewModel: ObservableObject {
    @Published var items: [Item] = []
    @Published var isLoading = false
    @Published var hasMoreData = true
    
    private var currentPage = 1
    private let pageSize = 30 // Larger page size for grid
    private let threshold = 6 // Load when 6 items from bottom
    
    func loadMoreIfNeeded(for item: Item) async {
        guard let itemIndex = items.firstIndex(where: { $0.id == item.id }) else {
            return
        }
        
        let thresholdIndex = items.count - threshold
        
        if itemIndex >= thresholdIndex {
            await loadMoreData()
        }
    }
    
    func loadMoreData() async {
        guard !isLoading && hasMoreData else { return }
        
        isLoading = true
        
        do {
            let newItems = try await APIService.shared.fetchItems(
                page: currentPage,
                pageSize: pageSize
            )
            
            if newItems.count < pageSize {
                hasMoreData = false
            }
            
            items.append(contentsOf: newItems)
            currentPage += 1
            
        } catch {
            print("Error loading grid data: \(error)")
        }
        
        isLoading = false
    }
    
    func loadInitialData() async {
        currentPage = 1
        hasMoreData = true
        await loadMoreData()
    }
    
    func refresh() async {
        currentPage = 1
        hasMoreData = true
        items.removeAll()
        await loadMoreData()
    }
}
</code></pre>
      </div>

      <h2 class="section-title">ğŸ¯ Performance Optimizations</h2>

      <div class="highlight-box">
        <h4>ØªØ­Ø³ÙŠÙ†Ø§Øª Ø§Ù„Ø£Ø¯Ø§Ø¡:</h4>
        <ol>
          <li><strong>LazyVStack/LazyHStack:</strong> Ù„Ù„Ù‚ÙˆØ§Ø¦Ù… Ø§Ù„Ø·ÙˆÙŠÙ„Ø©</li>
          <li><strong>Task Cancellation:</strong> Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù…ÙƒØ±Ø±Ø©</li>
          <li><strong>Debouncing:</strong> ØªØ£Ø®ÙŠØ± Ø§Ù„Ø¨Ø­Ø« Ù„ØªØ¬Ù†Ø¨ ÙƒØ«Ø±Ø© Ø§Ù„Ø·Ù„Ø¨Ø§Øª</li>
          <li><strong>Caching:</strong> Ø­ÙØ¸ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø­Ù…Ù„Ø©</li>
          <li><strong>Image Loading:</strong> Ø§Ø³ØªØ®Ø¯Ø§Ù… AsyncImage Ù…Ø¹ caching</li>
          <li><strong>Memory Management:</strong> ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© Ø¹Ù†Ø¯ Ø§Ù„Ø­Ø§Ø¬Ø©</li>
        </ol>
      </div>

      <div class="concept-box">
        <h5>Optimized ViewModel with Caching</h5>
      </div>

      <div class="code-container">
        <pre><code class="language-swift">
@MainActor
class OptimizedPaginationViewModel: ObservableObject {
    @Published var items: [Item] = []
    @Published var isLoading = false
    @Published var hasMoreData = true
    
    private var currentPage = 1
    private let pageSize = 20
    private var cache = NSCache<NSString, NSArray>()
    private var loadingTask: Task<Void, Never>?
    
    func loadMoreData() async {
        guard !isLoading && hasMoreData else { return }
        
        // Cancel previous loading task
        loadingTask?.cancel()
        
        loadingTask = Task {
            isLoading = true
            
            defer {
                isLoading = false
            }
            
            // Check cache first
            let cacheKey = "page_\(currentPage)" as NSString
            if let cachedItems = cache.object(forKey: cacheKey) as? [Item] {
                if !Task.isCancelled {
                    items.append(contentsOf: cachedItems)
                    currentPage += 1
                }
                return
            }
            
            do {
                let newItems = try await APIService.shared.fetchItems(
                    page: currentPage,
                    pageSize: pageSize
                )
                
                if !Task.isCancelled {
                    // Cache the results
                    cache.setObject(newItems as NSArray, forKey: cacheKey)
                    
                    items.append(contentsOf: newItems)
                    currentPage += 1
                    
                    if newItems.count < pageSize {
                        hasMoreData = false
                    }
                }
                
            } catch {
                if !Task.isCancelled {
                    print("Error loading data: \(error)")
                }
            }
        }
    }
    
    deinit {
        loadingTask?.cancel()
    }
}
</code></pre>
      </div>

      <h2 class="section-title">ğŸ“Š Ø§Ù„Ø®Ù„Ø§ØµØ©</h2>

      <div class="concept-box">
        <p>
          <strong>Infinite Scrolling ÙÙŠ SwiftUI:</strong>
        </p>
        <ul>
          <li><strong>onAppear detection:</strong> Ø¹Ù„Ù‰ Ø¢Ø®Ø± Ø¹Ù†Ø§ØµØ± Ù„Ù„ØªØ­Ù…ÙŠÙ„</li>
          <li><strong>Threshold loading:</strong> ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù‚Ø¨Ù„ Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù„Ù†Ù‡Ø§ÙŠØ©</li>
          <li><strong>Error handling:</strong> Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ Ø¨Ø·Ø±ÙŠÙ‚Ø© Ù…Ù†Ø§Ø³Ø¨Ø©</li>
          <li><strong>Search integration:</strong> Ø¯Ù…Ø¬ Ø§Ù„Ø¨Ø­Ø« Ù…Ø¹ Ø§Ù„Ù€ pagination</li>
          <li><strong>Performance optimization:</strong> Ø§Ø³ØªØ®Ø¯Ø§Ù… LazyViews Ùˆcaching</li>
          <li><strong>Task management:</strong> Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù…ÙƒØ±Ø±Ø©</li>
        </ul>
      </div>

      <div class="mt-4">
        <a href="../SwiftUI_Interview_Questions.html" class="back-btn">
          â† Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
        </a>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/autoloader/prism-autoloader.min.js"></script>
  </body>
</html>