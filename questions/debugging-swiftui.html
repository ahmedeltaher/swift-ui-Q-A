<!DOCTYPE html>
<html lang="ar" dir="rtl">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Debugging SwiftUI Views and Performance</title>
    
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-tomorrow.min.css" rel="stylesheet">
    
    <style>
      body {
        font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
        line-height: 1.6;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        direction: rtl;
      }
      .container {
        background: white;
        border-radius: 15px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        margin: 2rem auto;
        padding: 2rem;
        max-width: 1200px;
      }
      .question-title {
        color: #2c3e50;
        border-bottom: 3px solid #3498db;
        padding-bottom: 1rem;
        margin-bottom: 2rem;
        font-weight: 700;
      }
      .section-title {
        color: #e74c3c;
        margin: 2rem 0 1rem 0;
        font-weight: 600;
        font-size: 1.3rem;
      }
      .code-container {
        background: #2d3748;
        border-radius: 10px;
        padding: 1.5rem;
        margin: 1rem 0;
        overflow-x: auto;
      }
      .code-container code {
        color: #e2e8f0;
        font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
      }
      .highlight-box {
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
        padding: 1.5rem;
        border-radius: 10px;
        margin: 1.5rem 0;
      }
      .back-btn {
        background: linear-gradient(135deg, #667eea, #764ba2);
        border: none;
        color: white;
        padding: 0.7rem 1.5rem;
        border-radius: 25px;
        font-weight: 600;
        transition: transform 0.3s ease;
        text-decoration: none;
        display: inline-block;
        margin-bottom: 2rem;
      }
      .back-btn:hover {
        transform: translateY(-2px);
        color: white;
      }
      .concept-box {
        background: #f8f9fa;
        border-left: 4px solid #3498db;
        padding: 1rem 1.5rem;
        margin: 1rem 0;
        border-radius: 0 8px 8px 0;
      }
      .warning-box {
        background: #fff3cd;
        border-left: 4px solid #ffc107;
        padding: 1rem 1.5rem;
        margin: 1rem 0;
        border-radius: 0 8px 8px 0;
      }
      .success-box {
        background: #d1edff;
        border-left: 4px solid #17a2b8;
        padding: 1rem 1.5rem;
        margin: 1rem 0;
        border-radius: 0 8px 8px 0;
      }
    </style>
  </head>

  <body>
    <div class="container">
      <a href="../SwiftUI_Interview_Questions.html" class="back-btn">
        â† Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„ØµÙØ­Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
      </a>

      <h1 class="question-title">
        How to debug SwiftUI views and performance issues?
      </h1>

      <div class="highlight-box">
        <h4>ğŸ” Ø§Ù„ÙÙƒØ±Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©</h4>
        <p>
          <strong>Debugging SwiftUI</strong> Ø¨ÙŠØªØ·Ù„Ø¨ ÙÙ‡Ù… Ø§Ù„Ù€ View lifecycleØŒ Ùˆamation timingØŒ Ùˆperformance bottlenecks. 
          Ù…Ù† Ø§Ù„Ù€ Print statements Ø§Ù„Ø¨Ø³ÙŠØ·Ø© Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Instruments Ø§Ù„Ù…ØªÙ‚Ø¯Ù… ÙˆØ§Ù„Ù€ View Hierarchy debugging.
        </p>
      </div>

      <h2 class="section-title">ğŸ“ Ø§Ù„Ø´Ø±Ø­ Ø¨Ø§Ù„Ø¹Ø±Ø¨ÙŠ</h2>
      <p>
        Debugging ÙÙŠ SwiftUI Ù…Ø®ØªÙ„Ù Ø¹Ù† UIKit Ù„Ø£Ù† declarative nature Ø¨ÙŠØ®Ù„ÙŠ 
        Ø§Ù„Ù€ view updates ØºÙŠØ± Ù…Ø¨Ø§Ø´Ø±Ø©. Ù…Ø­ØªØ§Ø¬ ØªÙÙ‡Ù… ÙƒÙŠÙ Ø§Ù„Ù€ state changes Ø¨ØªØ£Ø«Ø± Ø¹Ù„Ù‰ 
        Ø§Ù„Ù€ view rebuilding ÙˆØªØ¹Ø±Ù ØªØªØ¨Ø¹ performance issues ÙˆØ§Ù„Ù€ view lifecycle.
      </p>

      <h2 class="section-title">ğŸ¯ Basic Debugging Techniques</h2>

      <div class="success-box">
        <h5>1. Print Debugging and View Lifecycle</h5>
        <p>Ø§Ø³ØªØ®Ø¯Ø§Ù… print statements Ù„ØªØªØ¨Ø¹ Ø§Ù„Ù€ view lifecycle ÙˆØ§Ù„Ù€ state changes</p>
      </div>

      <div class="code-container">
        <pre><code class="language-swift">
import SwiftUI

// Custom debugging view modifier
struct DebugModifier: ViewModifier {
    let id: String
    
    func body(content: Content) -> some View {
        content
            .onAppear {
                print("ğŸŸ¢ [\(id)] View appeared")
            }
            .onDisappear {
                print("ğŸ”´ [\(id)] View disappeared")
            }
    }
}

extension View {
    func debug(_ id: String) -> some View {
        modifier(DebugModifier(id: id))
    }
}

// State debugging helper
@propertyWrapper
struct DebugState<Value>: DynamicProperty {
    @State private var value: Value
    private let name: String
    
    init(wrappedValue: Value, _ name: String) {
        self._value = State(wrappedValue: wrappedValue)
        self.name = name
        print("ğŸ”¨ [\(name)] Initial value: \(wrappedValue)")
    }
    
    var wrappedValue: Value {
        get {
            print("ğŸ“– [\(name)] Reading value: \(value)")
            return value
        }
        nonmutating set {
            print("âœï¸ [\(name)] Writing value: \(value) -> \(newValue)")
            value = newValue
        }
    }
    
    var projectedValue: Binding<Value> {
        Binding(
            get: { self.wrappedValue },
            set: { self.wrappedValue = $0 }
        )
    }
}

// Performance debugging view
struct DebuggableView: View {
    @DebugState("Counter") var counter = 0
    @DebugState("IsVisible") var isVisible = true
    @State private var items: [String] = []
    
    var body: some View {
        VStack(spacing: 20) {
            Text("Debug Counter: \(counter)")
                .debug("CounterText")
            
            Button("Increment") {
                counter += 1
            }
            .debug("IncrementButton")
            
            Button("Toggle Visibility") {
                isVisible.toggle()
            }
            .debug("ToggleButton")
            
            if isVisible {
                expensiveView
                    .debug("ExpensiveView")
            }
            
            Button("Add Items") {
                addItems()
            }
            .debug("AddButton")
            
            LazyVStack {
                ForEach(items, id: \.self) { item in
                    Text(item)
                        .debug("Item-\(item)")
                }
            }
            .debug("ItemsList")
        }
        .debug("MainView")
        .onAppear {
            print("ğŸš€ Main view appeared")
            measurePerformance()
        }
    }
    
    private var expensiveView: some View {
        // Simulate expensive computation
        let _ = print("ğŸ’° Expensive view being created")
        return VStack {
            ForEach(0..<100, id: \.self) { i in
                Text("Heavy item \(i)")
                    .background(Color.red.opacity(0.1))
            }
        }
    }
    
    private func addItems() {
        print("ğŸ“ Adding items...")
        let startTime = CFAbsoluteTimeGetCurrent()
        
        items.append(contentsOf: (0..<10).map { "Item \($0 + items.count)" })
        
        let timeElapsed = CFAbsoluteTimeGetCurrent() - startTime
        print("â±ï¸ Items added in \(timeElapsed) seconds")
    }
    
    private func measurePerformance() {
        let startTime = CFAbsoluteTimeGetCurrent()
        
        // Simulate some work
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
            let timeElapsed = CFAbsoluteTimeGetCurrent() - startTime
            print("âš¡ Performance measurement: \(timeElapsed) seconds")
        }
    }
}
</code></pre>
      </div>

      <h2 class="section-title">ğŸ”¬ Advanced Debugging Tools</h2>

      <div class="concept-box">
        <h5>Ø§Ø³ØªØ®Ø¯Ø§Ù… View Inspector ÙˆSelf-Sizing</h5>
        <p>Ø£Ø¯ÙˆØ§Øª Ù…ØªÙ‚Ø¯Ù…Ø© Ù„ÙÙ‡Ù… Ø§Ù„Ù€ view hierarchy ÙˆØ§Ù„Ù€ layout issues</p>
      </div>

      <div class="code-container">
        <pre><code class="language-swift">
// View Inspector for debugging layouts
struct ViewInspector<Content: View>: View {
    let content: Content
    let title: String
    @State private var frame: CGRect = .zero
    
    init(_ title: String, @ViewBuilder content: () -> Content) {
        self.title = title
        self.content = content()
    }
    
    var body: some View {
        content
            .background(
                GeometryReader { geometry in
                    Color.clear
                        .onAppear {
                            frame = geometry.frame(in: .global)
                            print("ğŸ“ [\(title)] Frame: \(frame)")
                        }
                        .onChange(of: geometry.frame(in: .global)) { newFrame in
                            frame = newFrame
                            print("ğŸ“ [\(title)] Frame changed: \(frame)")
                        }
                }
            )
            .overlay(
                VStack {
                    HStack {
                        Text("\(title)")
                            .font(.caption2)
                            .padding(4)
                            .background(Color.black.opacity(0.7))
                            .foregroundColor(.white)
                            .cornerRadius(4)
                        Spacer()
                    }
                    Spacer()
                }
            )
    }
}

// Memory debugging helper
class MemoryDebugger: ObservableObject {
    @Published var memoryUsage: String = ""
    private var timer: Timer?
    
    init() {
        startMonitoring()
    }
    
    deinit {
        timer?.invalidate()
    }
    
    private func startMonitoring() {
        timer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { _ in
            self.updateMemoryUsage()
        }
    }
    
    private func updateMemoryUsage() {
        let info = mach_task_basic_info()
        var count = mach_msg_type_number_t(MemoryLayout<mach_task_basic_info>.size)/4
        
        let kerr: kern_return_t = withUnsafeMutablePointer(to: &info) {
            $0.withMemoryRebound(to: integer_t.self, capacity: 1) {
                task_info(mach_task_self_,
                         task_flavor_t(MACH_TASK_BASIC_INFO),
                         $0,
                         &count)
            }
        }
        
        if kerr == KERN_SUCCESS {
            let usedMB = Double(info.resident_size) / 1024.0 / 1024.0
            DispatchQueue.main.async {
                self.memoryUsage = String(format: "%.1f MB", usedMB)
                if usedMB > 100 { // Alert if memory usage is high
                    print("âš ï¸ High memory usage: \(self.memoryUsage)")
                }
            }
        }
    }
}

// Performance monitoring view
struct PerformanceMonitor: View {
    @StateObject private var memoryDebugger = MemoryDebugger()
    @State private var frameRate: Double = 60.0
    @State private var lastUpdate = Date()
    
    var body: some View {
        VStack {
            HStack {
                Text("Memory: \(memoryDebugger.memoryUsage)")
                Spacer()
                Text("FPS: \(frameRate, specifier: "%.1f")")
            }
            .font(.caption)
            .padding(8)
            .background(Color.black.opacity(0.8))
            .foregroundColor(.white)
            .cornerRadius(8)
        }
        .onReceive(Timer.publish(every: 1/60, on: .main, in: .common).autoconnect()) { _ in
            updateFrameRate()
        }
    }
    
    private func updateFrameRate() {
        let now = Date()
        let interval = now.timeIntervalSince(lastUpdate)
        frameRate = 1.0 / interval
        lastUpdate = now
        
        if frameRate < 50 {
            print("âš ï¸ Low frame rate: \(frameRate)")
        }
    }
}

// Animation debugging
struct AnimationDebugger: View {
    @State private var isAnimating = false
    @State private var animationProgress: Double = 0
    
    var body: some View {
        VStack(spacing: 20) {
            Text("Animation Debug")
                .font(.title)
            
            Circle()
                .fill(Color.blue)
                .frame(width: 50, height: 50)
                .scaleEffect(isAnimating ? 1.5 : 1.0)
                .rotationEffect(.degrees(animationProgress * 360))
                .animation(
                    .easeInOut(duration: 2.0)
                    .repeatForever(autoreverses: true),
                    value: isAnimating
                )
                .onAnimationCompleted(for: animationProgress) {
                    print("ğŸ¬ Animation completed for progress: \(animationProgress)")
                }
            
            Button("Start Animation") {
                print("ğŸ¬ Starting animation")
                isAnimating.toggle()
                
                withAnimation(.linear(duration: 4.0)) {
                    animationProgress = isAnimating ? 1.0 : 0.0
                }
            }
            
            Slider(value: $animationProgress, in: 0...1)
                .onChange(of: animationProgress) { value in
                    print("ğŸšï¸ Animation progress: \(value)")
                }
        }
        .overlay(PerformanceMonitor(), alignment: .topTrailing)
    }
}

// Animation completion detection
extension View {
    func onAnimationCompleted<Value: VectorArithmetic>(
        for value: Value,
        completion: @escaping () -> Void
    ) -> some View {
        modifier(AnimationCompletionModifier(targetValue: value, completion: completion))
    }
}

struct AnimationCompletionModifier<Value: VectorArithmetic>: ViewModifier {
    let targetValue: Value
    let completion: () -> Void
    
    @State private var lastValue: Value?
    
    func body(content: Content) -> some View {
        content
            .onChange(of: targetValue) { newValue in
                if let last = lastValue, last != newValue {
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                        if targetValue == newValue {
                            completion()
                        }
                    }
                }
                lastValue = newValue
            }
    }
}
</code></pre>
      </div>

      <h2 class="section-title">ğŸ› ï¸ Common Debugging Scenarios</h2>

      <div class="warning-box">
        <h5>Ø­Ù„ Ø§Ù„Ù…Ø´Ø§ÙƒÙ„ Ø§Ù„Ø´Ø§Ø¦Ø¹Ø©</h5>
        <p>Ù…Ø¬Ù…ÙˆØ¹Ø© Ù…Ù† Ø§Ù„Ø­Ù„ÙˆÙ„ Ù„Ù„Ù…Ø´Ø§ÙƒÙ„ Ø§Ù„Ø´Ø§Ø¦Ø¹Ø© ÙÙŠ SwiftUI</p>
      </div>

      <div class="code-container">
        <pre><code class="language-swift">
// State debugging scenarios
struct StateDebuggingView: View {
    @State private var count = 0
    @State private var isLoading = false
    @StateObject private var viewModel = DebugViewModel()
    
    var body: some View {
        VStack(spacing: 20) {
            // Problem: State not updating
            problematicStateView
            
            // Problem: Infinite updates
            fixedInfiniteUpdateView
            
            // Problem: Memory leaks
            memoryLeakFixedView
        }
    }
    
    // Problem: View not updating when it should
    private var problematicStateView: some View {
        VStack {
            Text("Count: \(count)")
                .onTapGesture {
                    // Wrong: This won't trigger view update
                    // count = count + 1
                    
                    // Correct: Use proper state mutation
                    count += 1
                    print("ğŸ”„ Count updated to: \(count)")
                }
            
            // Debug: Check if view is rebuilding
            let _ = print("ğŸ—ï¸ Count view rebuilding with count: \(count)")
        }
    }
    
    // Problem: onAppear called multiple times
    private var fixedInfiniteUpdateView: some View {
        VStack {
            Text("Loading: \(isLoading ? "Yes" : "No")")
                .onAppear {
                    // Wrong: This can cause infinite updates
                    // isLoading = true
                    
                    // Correct: Use task or check current state
                    if !isLoading {
                        print("ğŸ”„ Starting load operation")
                        loadData()
                    }
                }
        }
    }
    
    // Problem: Memory leaks with closures
    private var memoryLeakFixedView: some View {
        VStack {
            Text("View Model Count: \(viewModel.count)")
            
            Button("Increment") {
                // Correct: ViewModel automatically manages memory
                viewModel.increment()
            }
        }
    }
    
    private func loadData() {
        guard !isLoading else { return }
        
        isLoading = true
        print("ğŸ“¡ Starting data load...")
        
        DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
            isLoading = false
            print("âœ… Data load completed")
        }
    }
}

class DebugViewModel: ObservableObject {
    @Published var count = 0
    
    func increment() {
        print("ğŸ“ˆ ViewModel incrementing: \(count) -> \(count + 1)")
        count += 1
    }
    
    deinit {
        print("ğŸ—‘ï¸ ViewModel deallocated")
    }
}

// Layout debugging
struct LayoutDebuggingView: View {
    @State private var showDebugOverlay = false
    
    var body: some View {
        VStack {
            Toggle("Show Debug Overlay", isOn: $showDebugOverlay)
            
            HStack {
                debuggableView("Left")
                    .background(showDebugOverlay ? Color.red.opacity(0.3) : Color.clear)
                
                debuggableView("Center")
                    .background(showDebugOverlay ? Color.green.opacity(0.3) : Color.clear)
                
                debuggableView("Right")
                    .background(showDebugOverlay ? Color.blue.opacity(0.3) : Color.clear)
            }
            .overlay(
                showDebugOverlay ? 
                GeometryReader { geometry in
                    Path { path in
                        // Draw center lines for debugging
                        let center = CGPoint(x: geometry.size.width / 2, y: geometry.size.height / 2)
                        path.move(to: CGPoint(x: 0, y: center.y))
                        path.addLine(to: CGPoint(x: geometry.size.width, y: center.y))
                        path.move(to: CGPoint(x: center.x, y: 0))
                        path.addLine(to: CGPoint(x: center.x, y: geometry.size.height))
                    }
                    .stroke(Color.purple, lineWidth: 1)
                } : nil
            )
        }
        .padding()
    }
    
    private func debuggableView(_ title: String) -> some View {
        ViewInspector(title) {
            VStack {
                Text(title)
                    .padding()
                    .background(Color.gray.opacity(0.2))
                    .cornerRadius(8)
            }
        }
    }
}

// Network debugging
class NetworkDebugger: ObservableObject {
    @Published var requests: [NetworkRequest] = []
    
    struct NetworkRequest: Identifiable {
        let id = UUID()
        let url: String
        let method: String
        let timestamp: Date
        let duration: TimeInterval?
        let statusCode: Int?
        let error: String?
    }
    
    func logRequest(
        url: String,
        method: String = "GET",
        duration: TimeInterval? = nil,
        statusCode: Int? = nil,
        error: String? = nil
    ) {
        let request = NetworkRequest(
            url: url,
            method: method,
            timestamp: Date(),
            duration: duration,
            statusCode: statusCode,
            error: error
        )
        
        requests.append(request)
        
        print("ğŸŒ Network Request: \(method) \(url)")
        if let statusCode = statusCode {
            print("ğŸ“Š Status: \(statusCode)")
        }
        if let duration = duration {
            print("â±ï¸ Duration: \(duration)s")
        }
        if let error = error {
            print("âŒ Error: \(error)")
        }
    }
}

struct NetworkDebugView: View {
    @StateObject private var networkDebugger = NetworkDebugger()
    
    var body: some View {
        NavigationView {
            List(networkDebugger.requests) { request in
                VStack(alignment: .leading, spacing: 4) {
                    HStack {
                        Text(request.method)
                            .font(.caption)
                            .padding(.horizontal, 8)
                            .padding(.vertical, 2)
                            .background(methodColor(request.method))
                            .foregroundColor(.white)
                            .cornerRadius(4)
                        
                        Spacer()
                        
                        if let statusCode = request.statusCode {
                            Text("\(statusCode)")
                                .font(.caption)
                                .foregroundColor(statusColor(statusCode))
                        }
                    }
                    
                    Text(request.url)
                        .font(.body)
                        .lineLimit(2)
                    
                    HStack {
                        Text(request.timestamp, style: .time)
                            .font(.caption)
                            .foregroundColor(.secondary)
                        
                        if let duration = request.duration {
                            Text("\(duration, specifier: "%.2f")s")
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }
                        
                        if let error = request.error {
                            Text("Error: \(error)")
                                .font(.caption)
                                .foregroundColor(.red)
                        }
                    }
                }
                .padding(.vertical, 4)
            }
            .navigationTitle("Network Debug")
            .toolbar {
                Button("Test Request") {
                    simulateNetworkRequest()
                }
            }
        }
    }
    
    private func methodColor(_ method: String) -> Color {
        switch method {
        case "GET": return .blue
        case "POST": return .green
        case "PUT": return .orange
        case "DELETE": return .red
        default: return .gray
        }
    }
    
    private func statusColor(_ statusCode: Int) -> Color {
        switch statusCode {
        case 200..<300: return .green
        case 300..<400: return .orange
        case 400..<500: return .red
        case 500...: return .purple
        default: return .gray
        }
    }
    
    private func simulateNetworkRequest() {
        let urls = [
            "https://api.example.com/users",
            "https://api.example.com/posts",
            "https://api.example.com/comments"
        ]
        
        let url = urls.randomElement()!
        
        networkDebugger.logRequest(url: url, method: "GET")
        
        // Simulate network delay
        DispatchQueue.main.asyncAfter(deadline: .now() + Double.random(in: 0.5...2.0)) {
            let statusCode = [200, 201, 404, 500].randomElement()!
            let duration = Double.random(in: 0.1...2.0)
            
            networkDebugger.logRequest(
                url: url,
                method: "GET",
                duration: duration,
                statusCode: statusCode,
                error: statusCode >= 400 ? "Request failed" : nil
            )
        }
    }
}
</code></pre>
      </div>

      <h2 class="section-title">âš¡ Performance Optimization</h2>

      <div class="success-box">
        <h5>ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø£Ø¯Ø§Ø¡ ÙˆÙ…Ù†Ø¹ Ø§Ù„Ù…Ø´Ø§ÙƒÙ„</h5>
        <p>ØªÙ‚Ù†ÙŠØ§Øª Ù„ØªØ­Ø³ÙŠÙ† Ø£Ø¯Ø§Ø¡ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ ÙˆÙ…Ù†Ø¹ performance bottlenecks</p>
      </div>

      <div class="code-container">
        <pre><code class="language-swift">
// Performance optimization techniques
struct OptimizedListView: View {
    @State private var items: [ListItem] = []
    @State private var isLoading = false
    
    struct ListItem: Identifiable, Hashable {
        let id = UUID()
        let title: String
        let subtitle: String
        let imageURL: String?
    }
    
    var body: some View {
        NavigationView {
            List {
                // Optimized: Use LazyVStack for large lists
                LazyVStack(spacing: 0) {
                    ForEach(items) { item in
                        OptimizedListRow(item: item)
                            .onAppear {
                                // Load more items when near the end
                                if item == items.last {
                                    loadMoreItems()
                                }
                            }
                    }
                }
            }
            .navigationTitle("Optimized List")
            .refreshable {
                await refreshItems()
            }
            .task {
                await loadInitialItems()
            }
        }
    }
    
    private func loadInitialItems() async {
        guard items.isEmpty else { return }
        
        isLoading = true
        defer { isLoading = false }
        
        // Simulate API call
        try? await Task.sleep(nanoseconds: 1_000_000_000)
        
        items = (0..<20).map { index in
            ListItem(
                title: "Item \(index)",
                subtitle: "Subtitle for item \(index)",
                imageURL: "https://picsum.photos/100/100?random=\(index)"
            )
        }
    }
    
    private func loadMoreItems() {
        guard !isLoading else { return }
        
        Task {
            isLoading = true
            defer { isLoading = false }
            
            try? await Task.sleep(nanoseconds: 500_000_000)
            
            let newItems = (items.count..<items.count + 10).map { index in
                ListItem(
                    title: "Item \(index)",
                    subtitle: "Subtitle for item \(index)",
                    imageURL: "https://picsum.photos/100/100?random=\(index)"
                )
            }
            
            items.append(contentsOf: newItems)
        }
    }
    
    private func refreshItems() async {
        items.removeAll()
        await loadInitialItems()
    }
}

struct OptimizedListRow: View {
    let item: OptimizedListView.ListItem
    
    var body: some View {
        HStack {
            // Optimized: Use AsyncImage with placeholder
            AsyncImage(url: URL(string: item.imageURL ?? "")) { image in
                image
                    .resizable()
                    .aspectRatio(contentMode: .fill)
            } placeholder: {
                Rectangle()
                    .fill(Color.gray.opacity(0.3))
                    .overlay(
                        ProgressView()
                            .scaleEffect(0.5)
                    )
            }
            .frame(width: 60, height: 60)
            .clipped()
            .cornerRadius(8)
            
            VStack(alignment: .leading, spacing: 4) {
                Text(item.title)
                    .font(.headline)
                    .lineLimit(1)
                
                Text(item.subtitle)
                    .font(.subheadline)
                    .foregroundColor(.secondary)
                    .lineLimit(2)
            }
            
            Spacer()
        }
        .padding(.vertical, 8)
    }
}

// Memory efficient data handling
class EfficientDataManager: ObservableObject {
    @Published var items: [DataItem] = []
    private var cache: [String: DataItem] = [:]
    private let maxCacheSize = 100
    
    struct DataItem: Identifiable {
        let id: String
        let data: String
        let timestamp: Date
    }
    
    func loadItem(id: String) async -> DataItem? {
        // Check cache first
        if let cachedItem = cache[id] {
            print("ğŸ“‹ Cache hit for: \(id)")
            return cachedItem
        }
        
        print("ğŸŒ Loading from network: \(id)")
        
        // Simulate network load
        try? await Task.sleep(nanoseconds: 500_000_000)
        
        let item = DataItem(
            id: id,
            data: "Data for \(id)",
            timestamp: Date()
        )
        
        // Add to cache with size limit
        cache[id] = item
        if cache.count > maxCacheSize {
            // Remove oldest items
            let sortedKeys = cache.keys.sorted {
                cache[$0]!.timestamp < cache[$1]!.timestamp
            }
            cache.removeValue(forKey: sortedKeys.first!)
            print("ğŸ—‘ï¸ Cache evicted old item")
        }
        
        return item
    }
    
    func clearCache() {
        cache.removeAll()
        print("ğŸ§¹ Cache cleared")
    }
    
    deinit {
        print("ğŸ—‘ï¸ DataManager deallocated")
    }
}

// Debugging dashboard
struct DebuggingDashboard: View {
    @State private var selectedTab = 0
    
    var body: some View {
        TabView(selection: $selectedTab) {
            DebuggableView()
                .tabItem {
                    Image(systemName: "eye")
                    Text("View Debug")
                }
                .tag(0)
            
            AnimationDebugger()
                .tabItem {
                    Image(systemName: "play.circle")
                    Text("Animation")
                }
                .tag(1)
            
            LayoutDebuggingView()
                .tabItem {
                    Image(systemName: "square.grid.3x3")
                    Text("Layout")
                }
                .tag(2)
            
            NetworkDebugView()
                .tabItem {
                    Image(systemName: "network")
                    Text("Network")
                }
                .tag(3)
            
            OptimizedListView()
                .tabItem {
                    Image(systemName: "list.bullet")
                    Text("Performance")
                }
                .tag(4)
        }
    }
}
</code></pre>
      </div>

      <h2 class="section-title">ğŸ¯ Best Practices</h2>

      <div class="highlight-box">
        <h4>Ø£ÙØ¶Ù„ Ø§Ù„Ù…Ù…Ø§Ø±Ø³Ø§Øª Ù„Ù„Ù€ SwiftUI Debugging:</h4>
        <ol>
          <li><strong>Systematic Logging:</strong> Ø§Ø³ØªØ®Ø¯Ù… structured logging Ù„Ù„Ù€ view lifecycle</li>
          <li><strong>Performance Monitoring:</strong> Ø±Ø§Ù‚Ø¨ Ø§Ù„Ù€ memory usage ÙˆØ§Ù„Ù€ frame rate</li>
          <li><strong>State Tracking:</strong> ØªØªØ¨Ø¹ Ø§Ù„Ù€ state changes ÙˆØ§Ø³Ø¨Ø§Ø¨Ù‡Ø§</li>
          <li><strong>Visual Debugging:</strong> Ø§Ø³ØªØ®Ø¯Ù… debug overlays Ù„Ù„Ù€ layout issues</li>
          <li><strong>Instruments Integration:</strong> Ø§Ø³ØªØ®Ø¯Ù… Xcode Instruments Ù„Ù„Ù€ deep analysis</li>
          <li><strong>Testing:</strong> Ø§ÙƒØªØ¨ unit tests Ù„Ù„Ù€ view models ÙˆØ§Ù„Ù€ business logic</li>
        </ol>
      </div>

      <h2 class="section-title">ğŸ“Š Ø§Ù„Ø®Ù„Ø§ØµØ©</h2>

      <div class="concept-box">
        <p>
          <strong>SwiftUI Debugging Strategy:</strong>
        </p>
        <ul>
          <li><strong>Print Debugging:</strong> Ù„Ù„Ù€ quick insights ÙˆØ§Ù„Ù€ state tracking</li>
          <li><strong>Visual Debugging:</strong> Ù„Ù„Ù€ layout ÙˆØ§Ù„Ù€ animation issues</li>
          <li><strong>Performance Monitoring:</strong> Ù„Ù„Ù€ memory Ùˆframerate optimization</li>
          <li><strong>Instruments:</strong> Ù„Ù„Ù€ deep performance analysis</li>
          <li><strong>Systematic Approach:</strong> Ø§Ø³ØªØ®Ø¯Ù… debugging tools Ù…Ø¬ØªÙ…Ø¹Ø©</li>
          <li><strong>Prevention:</strong> Ø§ÙƒØªØ¨ clean code Ù…Ù† Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©</li>
        </ul>
      </div>

      <div class="mt-4">
        <a href="../SwiftUI_Interview_Questions.html" class="back-btn">
          â† Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
        </a>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/autoloader/prism-autoloader.min.js"></script>
  </body>
</html>