<!DOCTYPE html>
<html lang="ar" dir="rtl">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>List Performance Optimization in SwiftUI</title>
    
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-tomorrow.min.css" rel="stylesheet">
    
    <style>
      body {
        font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
        line-height: 1.6;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        direction: rtl;
      }
      .container {
        background: white;
        border-radius: 15px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        margin: 2rem auto;
        padding: 2rem;
        max-width: 1200px;
      }
      .question-title {
        color: #2c3e50;
        border-bottom: 3px solid #3498db;
        padding-bottom: 1rem;
        margin-bottom: 2rem;
        font-weight: 700;
      }
      .section-title {
        color: #e74c3c;
        margin: 2rem 0 1rem 0;
        font-weight: 600;
        font-size: 1.3rem;
      }
      .code-container {
        background: #2d3748;
        border-radius: 10px;
        padding: 1.5rem;
        margin: 1rem 0;
        overflow-x: auto;
      }
      .code-container code {
        color: #e2e8f0;
        font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
      }
      .highlight-box {
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
        padding: 1.5rem;
        border-radius: 10px;
        margin: 1.5rem 0;
      }
      .back-btn {
        background: linear-gradient(135deg, #667eea, #764ba2);
        border: none;
        color: white;
        padding: 0.7rem 1.5rem;
        border-radius: 25px;
        font-weight: 600;
        transition: transform 0.3s ease;
        text-decoration: none;
        display: inline-block;
        margin-bottom: 2rem;
      }
      .back-btn:hover {
        transform: translateY(-2px);
        color: white;
      }
      .concept-box {
        background: #f8f9fa;
        border-left: 4px solid #3498db;
        padding: 1rem 1.5rem;
        margin: 1rem 0;
        border-radius: 0 8px 8px 0;
      }
      .warning-box {
        background: #fff3cd;
        border-left: 4px solid #ffc107;
        padding: 1rem 1.5rem;
        margin: 1rem 0;
        border-radius: 0 8px 8px 0;
      }
      .success-box {
        background: #d1edff;
        border-left: 4px solid #17a2b8;
        padding: 1rem 1.5rem;
        margin: 1rem 0;
        border-radius: 0 8px 8px 0;
      }
      .performance-metric {
        background: #e8f5e8;
        border: 1px solid #28a745;
        border-radius: 8px;
        padding: 1rem;
        margin: 0.5rem 0;
        text-align: center;
      }
      .anti-pattern {
        background: #f8d7da;
        border: 1px solid #dc3545;
        border-radius: 8px;
        padding: 1rem;
        margin: 0.5rem 0;
      }
    </style>
  </head>

  <body>
    <div class="container">
      <a href="../SwiftUI_Interview_Questions.html" class="back-btn">
        â† Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„ØµÙØ­Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
      </a>

      <h1 class="question-title">
        How do you optimize List performance for large datasets?
      </h1>

      <div class="highlight-box">
        <h4>âš¡ Ø§Ù„ÙÙƒØ±Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©</h4>
        <p>
          ØªØ­Ø³ÙŠÙ† Ø£Ø¯Ø§Ø¡ Ø§Ù„Ù€ List ÙÙŠ SwiftUI Ø¨ÙŠØ¹ØªÙ…Ø¯ Ø¹Ù„Ù‰ <strong>lazy loading</strong> Ùˆ <strong>view recycling</strong> 
          Ùˆ <strong>efficient data structures</strong>. Ø£Ù‡Ù… Ø§Ù„ØªÙ‚Ù†ÙŠØ§Øª Ù‡ÙŠ Ø§Ø³ØªØ®Ø¯Ø§Ù… proper identifiersØŒ 
          ØªØ¬Ù†Ø¨ expensive computations ÙÙŠ Ø§Ù„Ù€ row viewsØŒ ÙˆØ§Ø³ØªØ®Ø¯Ø§Ù… LazyVStack Ù„Ù„Ù€ custom layouts.
        </p>
      </div>

      <h2 class="section-title">ğŸ“ Ø§Ù„Ø´Ø±Ø­ Ø¨Ø§Ù„Ø¹Ø±Ø¨ÙŠ</h2>
      <p>
        Ù„Ù…Ø§ ÙŠØ¨Ù‚Ù‰ Ø¹Ù†Ø¯Ùƒ Ø¢Ù„Ø§Ù Ù…Ù† Ø§Ù„Ù€ items ÙÙŠ ListØŒ Ø§Ù„Ø£Ø¯Ø§Ø¡ Ù…Ù…ÙƒÙ† ÙŠØ¨Ù‚Ù‰ Ø¨Ø·ÙŠØ¡ Ø¬Ø¯Ø§Ù‹ Ù„Ùˆ Ù…Ø´ Ù…Ø·Ø¨Ù‚ Ø§Ù„Ù€ best practices. 
        SwiftUI Ø¨ÙŠÙˆÙØ± lazy rendering Ø¨Ø³ Ù„Ø§Ø²Ù… ØªØ®Ù„ÙŠ Ø¨Ø§Ù„Ùƒ Ù…Ù† Ø§Ù„Ù€ view identityØŒ expensive operationsØŒ 
        ÙˆØ­Ø¬Ù… Ø§Ù„Ù€ data. Ø§Ù„Ù‡Ø¯Ù Ø¥Ù†Ù†Ø§ Ù†Ø®Ù„ÙŠ Ø§Ù„Ù€ scrolling smooth ÙˆÙ†Ù‚Ù„Ù„ Ø§Ø³ØªÙ‡Ù„Ø§Ùƒ Ø§Ù„Ù€ memory.
      </p>

      <h2 class="section-title">ğŸš« Common Performance Anti-Patterns</h2>

      <div class="anti-pattern">
        <h5>âŒ Ù…Ø´Ø§ÙƒÙ„ Ø´Ø§Ø¦Ø¹Ø© ØªØ¨Ø·Ø¦ Ø§Ù„Ù€ List</h5>
      </div>

      <div class="code-container">
        <pre><code class="language-swift">
import SwiftUI

// === ANTI-PATTERN 1: Expensive computations in row views ===
struct SlowListView: View {
    let items: [DataItem]
    
    struct DataItem: Identifiable {
        let id = UUID()
        let title: String
        let data: [Double]
        let timestamp: Date
    }
    
    var body: some View {
        List(items) { item in
            SlowRowView(item: item) // âŒ Creating heavy view for each row
        }
    }
}

struct SlowRowView: View {
    let item: SlowListView.DataItem
    
    var body: some View {
        VStack(alignment: .leading) {
            Text(item.title)
                .font(.headline)
            
            // âŒ PROBLEM: Expensive computation on every render
            Text("Average: \(calculateExpensiveAverage())")
                .font(.caption)
                .foregroundColor(.secondary)
            
            // âŒ PROBLEM: Complex date formatting on every render
            Text("Date: \(formatComplexDate())")
                .font(.caption)
        }
        .padding()
        .background(Color.gray.opacity(0.1))
        .cornerRadius(8)
    }
    
    private func calculateExpensiveAverage() -> String {
        // âŒ This runs on EVERY scroll and re-render!
        let sum = item.data.reduce(0, +)
        let average = sum / Double(item.data.count)
        
        // Simulate expensive computation
        Thread.sleep(forTimeInterval: 0.01) // 10ms delay PER ROW!
        
        return String(format: "%.2f", average)
    }
    
    private func formatComplexDate() -> String {
        // âŒ Creating new formatter every time
        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        formatter.timeStyle = .short
        return formatter.string(from: item.timestamp)
    }
}

// === ANTI-PATTERN 2: Missing or bad identifiers ===
struct BadIdentifierListView: View {
    @State private var items: [String] = []
    
    var body: some View {
        List(items, id: \.self) { item in // âŒ Using content as identifier
            HeavyRowView(text: item)
        }
        .onAppear {
            loadItems()
        }
    }
    
    private func loadItems() {
        // âŒ PROBLEM: Duplicate content means broken identity
        items = [
            "Item", "Item", "Item", // Same content = same ID!
            "Another Item", "Another Item"
        ]
    }
}

struct HeavyRowView: View {
    let text: String
    @State private var animationOffset: CGFloat = 0
    
    var body: some View {
        HStack {
            // âŒ PROBLEM: Heavy animation in every row
            Circle()
                .fill(Color.blue)
                .frame(width: 50, height: 50)
                .offset(x: animationOffset)
                .onAppear {
                    withAnimation(.linear(duration: 2).repeatForever()) {
                        animationOffset = 20
                    }
                }
            
            Text(text)
            
            Spacer()
        }
    }
}

// === ANTI-PATTERN 3: Loading all data at once ===
struct LoadAllDataView: View {
    @State private var allItems: [LargeDataItem] = []
    @State private var isLoading = false
    
    struct LargeDataItem: Identifiable {
        let id = UUID()
        let title: String
        let content: String
        let metadata: [String: Any] = [:]
        let largeData: Data
    }
    
    var body: some View {
        NavigationView {
            if isLoading {
                ProgressView("Loading all 10,000 items...")
            } else {
                // âŒ PROBLEM: All items loaded in memory at once
                List(allItems) { item in
                    VStack(alignment: .leading) {
                        Text(item.title)
                        Text("Size: \(item.largeData.count) bytes")
                            .font(.caption)
                    }
                }
            }
        }
        .task {
            await loadAllDataAtOnce() // âŒ Bad approach
        }
    }
    
    private func loadAllDataAtOnce() async {
        isLoading = true
        
        // âŒ Loading thousands of items with large data
        allItems = (1...10000).map { index in
            LargeDataItem(
                title: "Item \(index)",
                content: String(repeating: "Large content ", count: 100),
                largeData: Data(repeating: 0, count: 1000) // 1KB per item = 10MB total!
            )
        }
        
        isLoading = false
    }
}

// === ANTI-PATTERN 4: No view recycling optimization ===
struct NoRecyclingView: View {
    let items: [ComplexItem]
    
    struct ComplexItem: Identifiable {
        let id = UUID()
        let title: String
        let value: Double
        let category: String
    }
    
    var body: some View {
        List(items) { item in
            // âŒ PROBLEM: Complex view created for every item
            ComplexRowView(item: item)
        }
    }
}

struct ComplexRowView: View {
    let item: NoRecyclingView.ComplexItem
    @State private var isExpanded = false
    @State private var animationValue: Double = 0
    
    var body: some View {
        VStack {
            HStack {
                VStack(alignment: .leading) {
                    Text(item.title)
                        .font(.headline)
                    
                    Text(item.category)
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                
                Spacer()
                
                // âŒ PROBLEM: Heavy visual effects
                Circle()
                    .fill(
                        RadialGradient(
                            gradient: Gradient(colors: [.blue, .purple]),
                            center: .center,
                            startRadius: 0,
                            endRadius: 25
                        )
                    )
                    .frame(width: 50, height: 50)
                    .scaleEffect(1 + animationValue * 0.1)
                    .onAppear {
                        withAnimation(.easeInOut(duration: 1).repeatForever()) {
                            animationValue = 1
                        }
                    }
                
                Button(isExpanded ? "Collapse" : "Expand") {
                    withAnimation {
                        isExpanded.toggle()
                    }
                }
            }
            
            if isExpanded {
                // âŒ PROBLEM: Conditional content affects layout
                VStack {
                    Text("Value: \(item.value)")
                    Text("Additional details...")
                    Text("More content that takes space...")
                }
                .transition(.slide)
            }
        }
        .padding()
    }
}
</code></pre>
      </div>

      <h2 class="section-title">âœ… Optimized List Implementation</h2>

      <div class="performance-metric">
        <h5>ğŸš€ Performance Goals</h5>
        <p>60 FPS scrolling â€¢ Low memory usage â€¢ Instant response â€¢ Smooth animations</p>
      </div>

      <div class="code-container">
        <pre><code class="language-swift">
import SwiftUI

// === OPTIMIZED APPROACH 1: Efficient data structures and caching ===
struct OptimizedListView: View {
    @StateObject private var viewModel = ListViewModel()
    
    var body: some View {
        NavigationView {
            List {
                ForEach(viewModel.displayedItems) { item in
                    OptimizedRowView(item: item)
                        .onAppear {
                            viewModel.itemAppeared(item)
                        }
                }
                
                if viewModel.isLoadingMore {
                    HStack {
                        Spacer()
                        ProgressView()
                            .scaleEffect(0.8)
                        Text("Loading more...")
                            .font(.caption)
                        Spacer()
                    }
                    .padding()
                }
            }
            .refreshable {
                await viewModel.refresh()
            }
            .searchable(text: $viewModel.searchText)
            .navigationTitle("Optimized List")
        }
    }
}

// === Efficient ViewModel with pagination ===
@MainActor
class ListViewModel: ObservableObject {
    @Published var displayedItems: [OptimizedDataItem] = []
    @Published var searchText = ""
    @Published var isLoadingMore = false
    
    private var allItems: [OptimizedDataItem] = []
    private var currentPage = 0
    private let itemsPerPage = 50
    
    // âœ… Cached expensive computations
    private var computationCache: [UUID: ComputedValues] = [:]
    
    // âœ… Shared date formatter
    private let dateFormatter: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        formatter.timeStyle = .short
        return formatter
    }()
    
    struct ComputedValues {
        let average: String
        let formattedDate: String
    }
    
    init() {
        Task {
            await loadInitialData()
        }
    }
    
    func loadInitialData() async {
        await loadPage(0)
    }
    
    func refresh() async {
        currentPage = 0
        allItems.removeAll()
        displayedItems.removeAll()
        computationCache.removeAll()
        await loadPage(0)
    }
    
    func itemAppeared(_ item: OptimizedDataItem) {
        // âœ… Load more when reaching near the end
        if let index = displayedItems.firstIndex(where: { $0.id == item.id }),
           index >= displayedItems.count - 10 {
            Task {
                await loadMoreIfNeeded()
            }
        }
    }
    
    private func loadMoreIfNeeded() async {
        guard !isLoadingMore else { return }
        
        isLoadingMore = true
        await loadPage(currentPage + 1)
        isLoadingMore = false
    }
    
    private func loadPage(_ page: Int) async {
        // Simulate network delay
        try? await Task.sleep(nanoseconds: 500_000_000)
        
        let startIndex = page * itemsPerPage
        let endIndex = min(startIndex + itemsPerPage, 1000) // Max 1000 items
        
        let newItems = (startIndex..<endIndex).map { index in
            OptimizedDataItem(
                id: UUID(),
                title: "Optimized Item \(index + 1)",
                value: Double.random(in: 0...100),
                data: Array(repeating: Double.random(in: 0...10), count: 100),
                timestamp: Date().addingTimeInterval(Double(-index * 3600)),
                category: ["Tech", "Science", "Art", "Music"][index % 4]
            )
        }
        
        allItems.append(contentsOf: newItems)
        
        // âœ… Pre-compute expensive values
        await precomputeValues(for: newItems)
        
        updateDisplayedItems()
        currentPage = page
    }
    
    private func precomputeValues(for items: [OptimizedDataItem]) async {
        for item in items {
            // âœ… Compute once and cache
            let average = item.data.reduce(0, +) / Double(item.data.count)
            let averageString = String(format: "%.2f", average)
            let formattedDate = dateFormatter.string(from: item.timestamp)
            
            computationCache[item.id] = ComputedValues(
                average: averageString,
                formattedDate: formattedDate
            )
        }
    }
    
    func getComputedValues(for item: OptimizedDataItem) -> ComputedValues? {
        return computationCache[item.id]
    }
    
    private func updateDisplayedItems() {
        if searchText.isEmpty {
            displayedItems = allItems
        } else {
            displayedItems = allItems.filter { item in
                item.title.localizedCaseInsensitiveContains(searchText) ||
                item.category.localizedCaseInsensitiveContains(searchText)
            }
        }
    }
}

struct OptimizedDataItem: Identifiable {
    let id: UUID // âœ… Stable, unique identifier
    let title: String
    let value: Double
    let data: [Double]
    let timestamp: Date
    let category: String
}

// === Optimized Row View ===
struct OptimizedRowView: View {
    let item: OptimizedDataItem
    @EnvironmentObject private var viewModel: ListViewModel
    
    var body: some View {
        HStack {
            // âœ… Simple, efficient visual indicator
            CategoryIcon(category: item.category)
            
            VStack(alignment: .leading, spacing: 4) {
                Text(item.title)
                    .font(.headline)
                    .lineLimit(1)
                
                HStack {
                    // âœ… Using cached computed values
                    if let computed = viewModel.getComputedValues(for: item) {
                        Text("Avg: \(computed.average)")
                            .font(.caption)
                            .foregroundColor(.secondary)
                        
                        Spacer()
                        
                        Text(computed.formattedDate)
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }
            }
            
            Spacer()
            
            // âœ… Simple value display
            Text("\(item.value, specifier: "%.1f")")
                .font(.callout)
                .fontWeight(.medium)
                .foregroundColor(.blue)
        }
        .padding(.vertical, 8)
        .contentShape(Rectangle()) // âœ… Improves tap area
    }
}

struct CategoryIcon: View {
    let category: String
    
    var body: some View {
        // âœ… Simple, performant icon system
        Image(systemName: iconName)
            .foregroundColor(iconColor)
            .frame(width: 24, height: 24)
    }
    
    private var iconName: String {
        switch category {
        case "Tech": return "laptopcomputer"
        case "Science": return "flask"
        case "Art": return "paintbrush"
        case "Music": return "music.note"
        default: return "circle"
        }
    }
    
    private var iconColor: Color {
        switch category {
        case "Tech": return .blue
        case "Science": return .green
        case "Art": return .purple
        case "Music": return .orange
        default: return .gray
        }
    }
}

// === Advanced: Virtual Scrolling with LazyVStack ===
struct VirtualScrollingView: View {
    @StateObject private var virtualModel = VirtualScrollModel()
    
    var body: some View {
        NavigationView {
            ScrollViewReader { proxy in
                ScrollView {
                    LazyVStack(spacing: 1) {
                        ForEach(virtualModel.visibleItems) { item in
                            VirtualRowView(item: item)
                                .onAppear {
                                    virtualModel.itemBecameVisible(item)
                                }
                                .onDisappear {
                                    virtualModel.itemBecameInvisible(item)
                                }
                        }
                    }
                }
                .navigationTitle("Virtual Scrolling")
                .toolbar {
                    Button("Jump to 500") {
                        withAnimation {
                            proxy.scrollTo(virtualModel.getItemId(at: 500), anchor: .center)
                        }
                    }
                }
            }
        }
    }
}

@MainActor
class VirtualScrollModel: ObservableObject {
    @Published var visibleItems: [VirtualItem] = []
    
    private let totalItems = 10000
    private var visibleRange: ClosedRange<Int> = 0...100
    private let bufferSize = 50
    
    init() {
        updateVisibleItems()
    }
    
    func itemBecameVisible(_ item: VirtualItem) {
        // âœ… Expand visible range when needed
        if let index = getIndex(for: item.id) {
            let newStart = max(0, min(visibleRange.lowerBound, index - bufferSize))
            let newEnd = min(totalItems - 1, max(visibleRange.upperBound, index + bufferSize))
            
            if newStart != visibleRange.lowerBound || newEnd != visibleRange.upperBound {
                visibleRange = newStart...newEnd
                updateVisibleItems()
            }
        }
    }
    
    func itemBecameInvisible(_ item: VirtualItem) {
        // Could implement cleanup logic here
    }
    
    func getItemId(at index: Int) -> UUID {
        return UUID(uuidString: String(format: "%08X-0000-0000-0000-000000000000", index)) ?? UUID()
    }
    
    private func updateVisibleItems() {
        visibleItems = visibleRange.map { index in
            VirtualItem(
                id: getItemId(at: index),
                index: index,
                title: "Virtual Item \(index + 1)",
                content: "Content for item \(index + 1)"
            )
        }
    }
    
    private func getIndex(for id: UUID) -> Int? {
        return visibleItems.first { $0.id == id }?.index
    }
}

struct VirtualItem: Identifiable {
    let id: UUID
    let index: Int
    let title: String
    let content: String
}

struct VirtualRowView: View {
    let item: VirtualItem
    
    var body: some View {
        HStack {
            Text("#\(item.index + 1)")
                .font(.caption)
                .foregroundColor(.secondary)
                .frame(width: 50, alignment: .leading)
            
            VStack(alignment: .leading) {
                Text(item.title)
                    .font(.headline)
                
                Text(item.content)
                    .font(.body)
                    .foregroundColor(.secondary)
            }
            
            Spacer()
        }
        .padding()
        .background(Color.gray.opacity(0.05))
    }
}

// === Memory-Efficient Image Loading ===
struct ImageListView: View {
    @StateObject private var imageModel = ImageListModel()
    
    var body: some View {
        NavigationView {
            List(imageModel.items) { item in
                ImageRowView(item: item)
            }
            .navigationTitle("Images")
        }
    }
}

@MainActor
class ImageListModel: ObservableObject {
    @Published var items: [ImageItem] = []
    
    init() {
        items = (1...100).map { index in
            ImageItem(
                id: UUID(),
                title: "Image \(index)",
                imageURL: URL(string: "https://picsum.photos/200/200?random=\(index)")!
            )
        }
    }
}

struct ImageItem: Identifiable {
    let id: UUID
    let title: String
    let imageURL: URL
}

struct ImageRowView: View {
    let item: ImageItem
    
    var body: some View {
        HStack {
            // âœ… Efficient async image loading with placeholder
            AsyncImage(url: item.imageURL) { image in
                image
                    .resizable()
                    .aspectRatio(contentMode: .fill)
            } placeholder: {
                Rectangle()
                    .fill(Color.gray.opacity(0.3))
                    .overlay(
                        ProgressView()
                            .scaleEffect(0.6)
                    )
            }
            .frame(width: 60, height: 60)
            .clipped()
            .cornerRadius(8)
            
            VStack(alignment: .leading) {
                Text(item.title)
                    .font(.headline)
                
                Text("Tap to view")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            
            Spacer()
        }
        .padding(.vertical, 4)
    }
}
</code></pre>
      </div>

      <h2 class="section-title">âš¡ Advanced Optimization Techniques</h2>

      <div class="success-box">
        <h5>ğŸ¯ ØªÙ‚Ù†ÙŠØ§Øª Ù…ØªÙ‚Ø¯Ù…Ø© Ù„Ù„ØªØ­Ø³ÙŠÙ†</h5>
        <p>Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª Ù…ØªÙ‚Ø¯Ù…Ø© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø£ÙØ¶Ù„ Ø£Ø¯Ø§Ø¡ Ù…Ù…ÙƒÙ†</p>
      </div>

      <div class="code-container">
        <pre><code class="language-swift">
import SwiftUI

// === TECHNIQUE 1: Equatable Views for precise updates ===
struct EquatableOptimizedList: View {
    @State private var items: [EquatableItem] = []
    @State private var selectedIds: Set<UUID> = []
    
    var body: some View {
        List {
            ForEach(items) { item in
                EquatableRowView(
                    item: item,
                    isSelected: selectedIds.contains(item.id),
                    onToggle: { toggleSelection(item.id) }
                )
                .equatable() // âœ… Prevents unnecessary re-renders
            }
        }
        .onAppear {
            loadEquatableItems()
        }
    }
    
    private func toggleSelection(_ id: UUID) {
        if selectedIds.contains(id) {
            selectedIds.remove(id)
        } else {
            selectedIds.insert(id)
        }
    }
    
    private func loadEquatableItems() {
        items = (1...1000).map { index in
            EquatableItem(
                id: UUID(),
                title: "Item \(index)",
                value: Double.random(in: 0...100),
                isImportant: index % 10 == 0
            )
        }
    }
}

struct EquatableItem: Identifiable, Equatable {
    let id: UUID
    let title: String
    let value: Double
    let isImportant: Bool
    
    // âœ… Custom equality for performance
    static func == (lhs: EquatableItem, rhs: EquatableItem) -> Bool {
        lhs.id == rhs.id &&
        lhs.title == rhs.title &&
        lhs.value == rhs.value &&
        lhs.isImportant == rhs.isImportant
    }
}

struct EquatableRowView: View, Equatable {
    let item: EquatableItem
    let isSelected: Bool
    let onToggle: () -> Void
    
    var body: some View {
        HStack {
            // âœ… Conditional rendering only when needed
            if item.isImportant {
                Image(systemName: "star.fill")
                    .foregroundColor(.yellow)
            }
            
            VStack(alignment: .leading) {
                Text(item.title)
                    .font(.headline)
                
                Text("Value: \(item.value, specifier: "%.1f")")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            
            Spacer()
            
            Button(action: onToggle) {
                Image(systemName: isSelected ? "checkmark.circle.fill" : "circle")
                    .foregroundColor(isSelected ? .blue : .gray)
            }
        }
        .padding(.vertical, 4)
        .background(isSelected ? Color.blue.opacity(0.1) : Color.clear)
    }
    
    // âœ… Equatable implementation prevents unnecessary updates
    static func == (lhs: EquatableRowView, rhs: EquatableRowView) -> Bool {
        lhs.item == rhs.item && lhs.isSelected == rhs.isSelected
    }
}

// === TECHNIQUE 2: Sectioned List with Optimized Headers ===
struct OptimizedSectionedList: View {
    @StateObject private var sectionModel = SectionedListModel()
    
    var body: some View {
        NavigationView {
            List {
                ForEach(sectionModel.sections, id: \.category) { section in
                    Section {
                        ForEach(section.items) { item in
                            SectionItemView(item: item)
                        }
                    } header: {
                        // âœ… Lightweight header view
                        SectionHeaderView(
                            category: section.category,
                            count: section.items.count
                        )
                    }
                }
            }
            .navigationTitle("Sectioned List")
            .searchable(text: $sectionModel.searchText)
        }
    }
}

@MainActor
class SectionedListModel: ObservableObject {
    @Published var sections: [SectionData] = []
    @Published var searchText = "" {
        didSet {
            updateFilteredSections()
        }
    }
    
    private var allSections: [SectionData] = []
    
    struct SectionData {
        let category: String
        let items: [SectionItem]
    }
    
    init() {
        loadSectionedData()
    }
    
    private func loadSectionedData() {
        let categories = ["Work", "Personal", "Shopping", "Health", "Education"]
        
        allSections = categories.map { category in
            let items = (1...200).map { index in
                SectionItem(
                    id: UUID(),
                    title: "\(category) Item \(index)",
                    category: category,
                    priority: Int.random(in: 1...5)
                )
            }
            return SectionData(category: category, items: items)
        }
        
        sections = allSections
    }
    
    private func updateFilteredSections() {
        if searchText.isEmpty {
            sections = allSections
        } else {
            sections = allSections.compactMap { section in
                let filteredItems = section.items.filter { item in
                    item.title.localizedCaseInsensitiveContains(searchText)
                }
                
                return filteredItems.isEmpty ? nil : SectionData(
                    category: section.category,
                    items: filteredItems
                )
            }
        }
    }
}

struct SectionItem: Identifiable {
    let id: UUID
    let title: String
    let category: String
    let priority: Int
}

struct SectionHeaderView: View {
    let category: String
    let count: Int
    
    var body: some View {
        HStack {
            Text(category)
                .font(.headline)
                .fontWeight(.bold)
            
            Spacer()
            
            Text("\(count) items")
                .font(.caption)
                .foregroundColor(.secondary)
        }
        .padding(.vertical, 4)
    }
}

struct SectionItemView: View {
    let item: SectionItem
    
    var body: some View {
        HStack {
            VStack(alignment: .leading) {
                Text(item.title)
                    .font(.body)
                
                Text("Priority: \(item.priority)")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            
            Spacer()
            
            // âœ… Simple priority indicator
            ForEach(1...item.priority, id: \.self) { _ in
                Circle()
                    .fill(Color.orange)
                    .frame(width: 6, height: 6)
            }
        }
    }
}

// === TECHNIQUE 3: Diffable Data Source Pattern ===
struct DiffableListView: View {
    @StateObject private var diffModel = DiffableListModel()
    
    var body: some View {
        NavigationView {
            List {
                ForEach(diffModel.currentItems) { item in
                    DiffableItemView(item: item)
                        .transition(.asymmetric(
                            insertion: .scale.combined(with: .opacity),
                            removal: .opacity
                        ))
                }
                .onDelete(perform: diffModel.deleteItems)
                .onMove(perform: diffModel.moveItems)
            }
            .animation(.easeInOut(duration: 0.3), value: diffModel.currentItems)
            .navigationTitle("Diffable List")
            .toolbar {
                ToolbarItemGroup(placement: .navigationBarTrailing) {
                    Button("Add Random") {
                        diffModel.addRandomItem()
                    }
                    
                    Button("Shuffle") {
                        diffModel.shuffleItems()
                    }
                }
            }
        }
    }
}

@MainActor
class DiffableListModel: ObservableObject {
    @Published var currentItems: [DiffableItem] = []
    
    init() {
        currentItems = (1...20).map { index in
            DiffableItem(
                id: UUID(),
                title: "Diffable Item \(index)",
                value: Double.random(in: 0...100),
                color: [.red, .blue, .green, .orange, .purple].randomElement()!
            )
        }
    }
    
    func addRandomItem() {
        let newItem = DiffableItem(
            id: UUID(),
            title: "New Item \(Int.random(in: 100...999))",
            value: Double.random(in: 0...100),
            color: [.red, .blue, .green, .orange, .purple].randomElement()!
        )
        
        withAnimation {
            currentItems.insert(newItem, at: Int.random(in: 0...currentItems.count))
        }
    }
    
    func deleteItems(at offsets: IndexSet) {
        withAnimation {
            currentItems.remove(atOffsets: offsets)
        }
    }
    
    func moveItems(from source: IndexSet, to destination: Int) {
        withAnimation {
            currentItems.move(fromOffsets: source, toOffset: destination)
        }
    }
    
    func shuffleItems() {
        withAnimation {
            currentItems.shuffle()
        }
    }
}

struct DiffableItem: Identifiable, Equatable {
    let id: UUID
    let title: String
    let value: Double
    let color: Color
    
    static func == (lhs: DiffableItem, rhs: DiffableItem) -> Bool {
        lhs.id == rhs.id
    }
}

struct DiffableItemView: View {
    let item: DiffableItem
    
    var body: some View {
        HStack {
            Circle()
                .fill(item.color)
                .frame(width: 30, height: 30)
            
            VStack(alignment: .leading) {
                Text(item.title)
                    .font(.headline)
                
                Text("Value: \(item.value, specifier: "%.1f")")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            
            Spacer()
        }
        .padding(.vertical, 4)
    }
}

// === TECHNIQUE 4: Performance Monitoring ===
struct PerformanceMonitoredList: View {
    @StateObject private var monitor = PerformanceMonitor()
    @State private var items: [MonitoredItem] = []
    
    var body: some View {
        NavigationView {
            VStack {
                // âœ… Performance metrics display
                PerformanceStatsView(monitor: monitor)
                
                List(items) { item in
                    MonitoredItemView(item: item, monitor: monitor)
                }
            }
            .navigationTitle("Performance Monitor")
            .onAppear {
                loadMonitoredItems()
            }
        }
    }
    
    private func loadMonitoredItems() {
        items = (1...500).map { index in
            MonitoredItem(
                id: UUID(),
                title: "Monitored Item \(index)",
                complexity: Int.random(in: 1...5)
            )
        }
    }
}

@MainActor
class PerformanceMonitor: ObservableObject {
    @Published var rowRenderCount = 0
    @Published var averageRenderTime: Double = 0
    @Published var memoryWarnings = 0
    
    private var renderTimes: [Double] = []
    
    func recordRowRender(duration: Double) {
        rowRenderCount += 1
        renderTimes.append(duration)
        
        // Keep only last 100 measurements
        if renderTimes.count > 100 {
            renderTimes.removeFirst()
        }
        
        averageRenderTime = renderTimes.reduce(0, +) / Double(renderTimes.count)
        
        // Simulate memory warning detection
        if duration > 0.016 { // More than one frame (16ms)
            memoryWarnings += 1
        }
    }
}

struct PerformanceStatsView: View {
    @ObservedObject let monitor: PerformanceMonitor
    
    var body: some View {
        HStack {
            VStack {
                Text("\(monitor.rowRenderCount)")
                    .font(.title2)
                    .fontWeight(.bold)
                Text("Renders")
                    .font(.caption)
            }
            
            Spacer()
            
            VStack {
                Text("\(monitor.averageRenderTime * 1000, specifier: "%.1f")ms")
                    .font(.title2)
                    .fontWeight(.bold)
                    .foregroundColor(monitor.averageRenderTime > 0.016 ? .red : .green)
                Text("Avg Time")
                    .font(.caption)
            }
            
            Spacer()
            
            VStack {
                Text("\(monitor.memoryWarnings)")
                    .font(.title2)
                    .fontWeight(.bold)
                    .foregroundColor(monitor.memoryWarnings > 10 ? .red : .green)
                Text("Warnings")
                    .font(.caption)
            }
        }
        .padding()
        .background(Color.gray.opacity(0.1))
        .cornerRadius(8)
        .padding(.horizontal)
    }
}

struct MonitoredItem: Identifiable {
    let id: UUID
    let title: String
    let complexity: Int
}

struct MonitoredItemView: View {
    let item: MonitoredItem
    let monitor: PerformanceMonitor
    
    var body: some View {
        let startTime = CFAbsoluteTimeGetCurrent()
        
        return HStack {
            VStack(alignment: .leading) {
                Text(item.title)
                    .font(.headline)
                
                // Simulate complexity
                ForEach(1...item.complexity, id: \.self) { level in
                    Text("Complexity Level \(level)")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
            }
            
            Spacer()
            
            Text("C: \(item.complexity)")
                .font(.caption)
                .padding(4)
                .background(complexityColor)
                .cornerRadius(4)
        }
        .onAppear {
            let endTime = CFAbsoluteTimeGetCurrent()
            monitor.recordRowRender(duration: endTime - startTime)
        }
    }
    
    private var complexityColor: Color {
        switch item.complexity {
        case 1: return .green
        case 2: return .yellow
        case 3: return .orange
        case 4: return .red
        default: return .purple
        }
    }
}
</code></pre>
      </div>

      <h2 class="section-title">ğŸ¯ Performance Best Practices</h2>

      <div class="highlight-box">
        <h4>ğŸ“‹ Ø§Ù„Ù€ Checklist Ù„Ù„Ù€ List Performance</h4>
        <div>
          <h5>âœ… Essential Optimizations:</h5>
          <ul>
            <li><strong>Stable IDs:</strong> Ø§Ø³ØªØ®Ø¯Ù… UUID Ø£Ùˆ stable identifiers</li>
            <li><strong>Cache Computations:</strong> Ø§Ø­Ø³Ø¨ Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ù…Ø¹Ù‚Ø¯Ø© Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ÙÙ‚Ø·</li>
            <li><strong>Lazy Loading:</strong> Ø§Ø¹Ù…Ù„ pagination Ù„Ù„Ù€ data Ø§Ù„ÙƒØ¨ÙŠØ±Ø©</li>
            <li><strong>Simple Row Views:</strong> ØªØ¬Ù†Ø¨ Ø§Ù„Ù€ complex animations ÙÙŠ Ø§Ù„Ù€ rows</li>
            <li><strong>Equatable Views:</strong> Ø§Ø³ØªØ®Ø¯Ù… Equatable Ù„ØªØ¬Ù†Ø¨ unnecessary re-renders</li>
          </ul>
          
          <h5>ğŸš€ Advanced Techniques:</h5>
          <ul>
            <li><strong>Virtual Scrolling:</strong> Ù„Ù„Ù€ datasets Ø§Ù„Ø¶Ø®Ù…Ø© Ø¬Ø¯Ø§Ù‹</li>
            <li><strong>Image Optimization:</strong> Ø§Ø³ØªØ®Ø¯Ù… AsyncImage Ù…Ø¹ proper caching</li>
            <li><strong>Memory Monitoring:</strong> Ø±Ø§Ù‚Ø¨ Ø§Ù„Ø£Ø¯Ø§Ø¡ ÙˆØ§Ù„Ù€ memory usage</li>
            <li><strong>Sectioned Data:</strong> Ù‚Ø³Ù… Ø§Ù„Ù€ data Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„Ù€ navigation</li>
          </ul>
        </div>
      </div>

      <h2 class="section-title">ğŸ“Š Ø§Ù„Ø®Ù„Ø§ØµØ©</h2>

      <div class="concept-box">
        <p>
          <strong>List Performance Optimization Summary:</strong>
        </p>
        <ul>
          <li><strong>Data Structure:</strong> Ø§Ø³ØªØ®Ø¯Ù… stable IDs Ùˆpagination Ù„Ù„Ù€ large datasets</li>
          <li><strong>View Design:</strong> Ø§Ø¹Ù…Ù„ lightweight row views Ùˆcache expensive computations</li>
          <li><strong>Memory Management:</strong> Ø§Ø³ØªØ®Ø¯Ù… lazy loading Ùˆautomatic view recycling</li>
          <li><strong>Advanced Patterns:</strong> Virtual scrollingØŒ Equatable viewsØŒ Ùˆperformance monitoring</li>
          <li><strong>60 FPS Goal:</strong> Ø§Ù‡Ø¯Ù Ù„Ù€ render times Ø£Ù‚Ù„ Ù…Ù† 16ms per frame</li>
        </ul>
      </div>

      <div class="mt-4">
        <a href="../SwiftUI_Interview_Questions.html" class="back-btn">
          â† Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
        </a>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/autoloader/prism-autoloader.min.js"></script>
  </body>
</html>