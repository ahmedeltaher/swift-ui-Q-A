<!DOCTYPE html>
<html lang="ar" dir="rtl">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>What are the performance pitfalls in SwiftUI?</title>
  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <!-- Custom CSS -->
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #121212;
      color: #e0e0e0;
      padding: 20px;
    }

    .card {
      margin-bottom: 25px;
      border-radius: 15px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
      overflow: hidden;
      border: none;
    }

    .advanced-level {
      background: linear-gradient(135deg, #7ba69f 0%, #9ac2bb 100%);
    }

    .card-header {
      color: white;
      font-weight: bold;
      border-radius: 0 !important;
      padding: 20px;
      background: rgba(0, 0, 0, 0.1);
      border-bottom: 1px solid rgba(255, 255, 255, 0.2);
      text-align: center;
    }

    .card-body {
      padding: 25px;
      line-height: 1.8;
      color: white;
      text-align: left;
    }

    .main-title {
      background: linear-gradient(135deg, #7ba69f 0%, #9ac2bb 100%);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      text-align: center;
      margin-bottom: 30px;
      font-size: 2.5rem;
      font-weight: bold;
      filter: brightness(1.2);
      text-shadow: 0 0 15px rgba(123, 166, 159, 0.5);
    }

    .content-container {
      max-width: 900px;
      margin: 0 auto;
    }

    .answer-section {
      background-color: rgba(255, 255, 255, 0.1);
      border-radius: 15px;
      padding: 25px;
      margin-bottom: 25px;
      direction: ltr;
      text-align: left;
    }

    .explanation-section {
      background-color: rgba(255, 255, 255, 0.05);
      border-radius: 15px;
      padding: 25px;
      margin-bottom: 25px;
    }

    .answer-title,
    .explanation-title {
      font-weight: bold;
      margin-bottom: 15px;
      color: #e0e0e0;
    }

    .code-block {
      background-color: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      padding: 15px;
      margin: 15px 0;
      overflow-x: auto;
    }

    pre {
      color: #e0e0e0;
      margin: 0;
    }

    .back-button {
      background: linear-gradient(135deg, #7ba69f 0%, #9ac2bb 100%);
      color: white;
      border: none;
      border-radius: 8px;
      padding: 10px 20px;
      margin-bottom: 20px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-decoration: none;
      display: inline-block;
    }

    .back-button:hover {
      transform: translateY(-3px);
      box-shadow: 0 4px 15px rgba(123, 166, 159, 0.5);
      color: white;
      text-decoration: none;
    }

    footer {
      text-align: center;
      margin-top: 40px;
      color: #a0a0a0;
      padding: 20px;
    }

    .highlight {
      color: #9ac2bb;
      font-weight: bold;
    }

    .warning {
      color: #ff6b6b;
      font-weight: bold;
    }

    .success {
      color: #51cf66;
      font-weight: bold;
    }

    table {
      width: 100%;
      margin: 20px 0;
      border-collapse: collapse;
    }

    th,
    td {
      padding: 12px 15px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    th {
      background-color: rgba(0, 0, 0, 0.2);
    }

    tr:nth-child(even) {
      background-color: rgba(255, 255, 255, 0.03);
    }

    .pitfall-box {
      background-color: rgba(255, 107, 107, 0.1);
      border-radius: 8px;
      padding: 15px;
      margin: 10px 0;
      border-left: 4px solid #ff6b6b;
    }

    .solution-box {
      background-color: rgba(81, 207, 102, 0.1);
      border-radius: 8px;
      padding: 15px;
      margin: 10px 0;
      border-left: 4px solid #51cf66;
    }
  </style>
</head>

<body>
  <div class="content-container">
    <a href="../SwiftUI_Interview_Questions.html" class="back-button">← العودة للأسئلة</a>

    <h1 class="main-title">What are the performance pitfalls in SwiftUI?</h1>

    <div class="card advanced-level">
      <div class="card-header">
        <h3 class="mb-0">Answer in English</h3>
      </div>
      <div class="card-body">
        <div class="answer-section">
          <h4>Common Performance Pitfalls in SwiftUI:</h4>

          <div class="pitfall-box">
            <h5>1. Excessive Body Re-computations</h5>
            <p><span class="warning">Problem:</span> Views calling expensive operations in their body property.</p>
            <div class="code-block">
              <pre><code>// ❌ Bad - Expensive computation in body
struct SlowView: View {
    @State private var data: [Item] = []
    
    var body: some View {
        let processedData = heavyDataProcessing(data) // Called on every re-render
        
        List(processedData, id: \.id) { item in
            Text(item.name)
        }
    }
    
    func heavyDataProcessing(_ items: [Item]) -> [ProcessedItem] {
        // Expensive operation
        return items.map { processItem($0) }
    }
}</code></pre>
            </div>
          </div>

          <div class="solution-box">
            <h5>✅ Solution: Use computed properties or state</h5>
            <div class="code-block">
              <pre><code>// ✅ Good - Cache processed data
struct FastView: View {
    @State private var data: [Item] = []
    @State private var processedData: [ProcessedItem] = []
    
    var body: some View {
        List(processedData, id: \.id) { item in
            Text(item.name)
        }
        .onChange(of: data) { newData in
            processedData = heavyDataProcessing(newData)
        }
    }
}</code></pre>
            </div>
          </div>

          <div class="pitfall-box">
            <h5>2. Large ForEach Without Proper IDs</h5>
            <p><span class="warning">Problem:</span> Using array indices or improper identifiers for dynamic content.</p>
            <div class="code-block">
              <pre><code>// ❌ Bad - Using array indices
ForEach(0..<items.count, id: \.self) { index in
    ItemView(item: items[index])
}

// ❌ Bad - No stable identity
ForEach(items, id: \.name) { item in
    ItemView(item: item) // Name might not be unique
}</code></pre>
            </div>
          </div>

          <div class="solution-box">
            <h5>✅ Solution: Use stable, unique identifiers</h5>
            <div class="code-block">
              <pre><code>// ✅ Good - Stable unique ID
ForEach(items, id: \.id) { item in
    ItemView(item: item)
}

// ✅ Good - Conform to Identifiable
struct Item: Identifiable {
    let id = UUID()
    let name: String
}

ForEach(items) { item in
    ItemView(item: item)
}</code></pre>
            </div>
          </div>

          <div class="pitfall-box">
            <h5>3. Overusing AnyView</h5>
            <p><span class="warning">Problem:</span> Type erasure prevents SwiftUI optimizations.</p>
            <div class="code-block">
              <pre><code>// ❌ Bad - Unnecessary type erasure
@ViewBuilder
func buildContent() -> some View {
    if condition {
        AnyView(Text("Hello"))
    } else {
        AnyView(Button("Action") { })
    }
}</code></pre>
            </div>
          </div>

          <div class="solution-box">
            <h5>✅ Solution: Use concrete types or Group</h5>
            <div class="code-block">
              <pre><code>// ✅ Good - Concrete types
@ViewBuilder
func buildContent() -> some View {
    if condition {
        Text("Hello")
    } else {
        Button("Action") { }
    }
}

// ✅ Good - When type erasure is necessary
@ViewBuilder
func buildContent() -> some View {
    Group {
        if condition {
            Text("Hello")
        } else {
            Button("Action") { }
        }
    }
}</code></pre>
            </div>
          </div>

          <div class="pitfall-box">
            <h5>4. Not Using EquatableView for Complex Views</h5>
            <p><span class="warning">Problem:</span> Complex views re-rendering unnecessarily.</p>
            <div class="code-block">
              <pre><code>// ❌ Bad - Complex view without equality check
struct ComplexItemView: View {
    let item: ComplexItem
    
    var body: some View {
        // Expensive view building...
        VStack {
            ComplexChart(data: item.chartData)
            DetailedInfo(info: item.detailedInfo)
            ProcessedImage(image: item.processedImage)
        }
    }
}</code></pre>
            </div>
          </div>

          <div class="solution-box">
            <h5>✅ Solution: Implement Equatable and use EquatableView</h5>
            <div class="code-block">
              <pre><code>// ✅ Good - Using EquatableView
struct ComplexItemView: View, Equatable {
    let item: ComplexItem
    
    var body: some View {
        VStack {
            ComplexChart(data: item.chartData)
            DetailedInfo(info: item.detailedInfo)
            ProcessedImage(image: item.processedImage)
        }
    }
    
    static func == (lhs: ComplexItemView, rhs: ComplexItemView) -> Bool {
        lhs.item.id == rhs.item.id && lhs.item.version == rhs.item.version
    }
}

// Usage
EquatableView(content: ComplexItemView(item: item))</code></pre>
            </div>
          </div>

          <h4>Additional Performance Guidelines:</h4>

          <table>
            <tr>
              <th>Issue</th>
              <th>Impact</th>
              <th>Solution</th>
            </tr>
            <tr>
              <td>Heavy image processing</td>
              <td>UI freezing</td>
              <td>Use AsyncImage, background processing</td>
            </tr>
            <tr>
              <td>Large Lists</td>
              <td>Memory usage, scroll lag</td>
              <td>Use LazyVStack, LazyHStack</td>
            </tr>
            <tr>
              <td>Nested observations</td>
              <td>Cascading updates</td>
              <td>Minimize @ObservedObject depth</td>
            </tr>
            <tr>
              <td>Frequent timer updates</td>
              <td>Battery drain</td>
              <td>Use appropriate update intervals</td>
            </tr>
          </table>

          <h4>Best Practices Summary:</h4>
          <ul>
            <li>Keep body computations lightweight</li>
            <li>Use stable, unique identifiers for ForEach</li>
            <li>Avoid AnyView unless necessary</li>
            <li>Use EquatableView for expensive views</li>
            <li>Use Lazy containers for large datasets</li>
            <li>Cache expensive computations</li>
            <li>Profile your app with Instruments</li>
            <li>Use @StateObject for object ownership</li>
          </ul>

          <h4>Debugging Performance:</h4>
          <div class="code-block">
            <pre><code>// Use this to track body re-computations
var body: some View {
    let _ = print("Body computed for \(type(of: self))")
    
    return VStack {
        // Your view content
    }
}</code></pre>
          </div>
        </div>
      </div>
    </div>

    <div class="explanation-section">
      <h3 class="explanation-title">الشرح بالعربي</h3>
      
      <h4>مشاكل الأداء الشائعة في SwiftUI:</h4>
      
      <div class="pitfall-box">
        <h5>1. إعادة حساب الـ Body كتير</h5>
        <p><span class="warning">المشكلة:</span> عمل عمليات معقدة جوا الـ body property.</p>
        <p>لما تحط عمليات تقيلة في الـ body، هتتعمل كل مرة الـ view يتحدث!</p>
      </div>

      <div class="solution-box">
        <h5>✅ الحل: استخدم @State أو computed properties</h5>
        <p>احفظ نتيجة العمليات المعقدة في @State وحدثها بس لما تحتاج.</p>
      </div>

      <div class="pitfall-box">
        <h5>2. ForEach بدون IDs مناسبة</h5>
        <p><span class="warning">المشكلة:</span> استخدام أرقام المؤشرات أو IDs غير ثابتة.</p>
        <p>SwiftUI مش هيعرف ازاي يتعامل مع التغييرات بكفاءة.</p>
      </div>

      <div class="solution-box">
        <h5>✅ الحل: استخدم IDs ثابتة وفريدة</h5>
        <p>خلي كل عنصر له ID فريد وثابت، أو استخدم Identifiable protocol.</p>
      </div>

      <div class="pitfall-box">
        <h5>3. الإفراط في استخدام AnyView</h5>
        <p><span class="warning">المشكلة:</span> بيمنع SwiftUI من عمل optimizations.</p>
        <p>AnyView بيخبي نوع الـ view الحقيقي، فـ SwiftUI مش بيقدر يحسن الأداء.</p>
      </div>

      <div class="solution-box">
        <h5>✅ الحل: استخدم الأنواع الأصلية</h5>
        <p>استخدم @ViewBuilder وخلي SwiftUI يشوف الأنواع الحقيقية.</p>
      </div>

      <div class="pitfall-box">
        <h5>4. عدم استخدام EquatableView</h5>
        <p><span class="warning">المشكلة:</span> Views معقدة بتتحدث من غير داعي.</p>
        <p>لو الـ view تقيل في التحديث، هيأثر على الأداء.</p>
      </div>

      <div class="solution-box">
        <h5>✅ الحل: استخدم EquatableView</h5>
        <p>خلي الـ view يطبق Equatable واستخدم EquatableView wrapper.</p>
      </div>
      
      <h4>نصائح إضافية للأداء:</h4>
      <ul>
        <li><strong>Lazy Containers:</strong> استخدم LazyVStack للقوائم الطويلة</li>
        <li><strong>AsyncImage:</strong> للصور اللي محتاجة تحميل</li>
        <li><strong>Background Processing:</strong> العمليات التقيلة في background</li>
        <li><strong>State Management:</strong> قلل استخدام @ObservedObject المتداخل</li>
      </ul>
      
      <h4>ازاي تكتشف مشاكل الأداء:</h4>
      <div class="code-block">
        <pre><code>// حط دا في الـ body عشان تشوف إمتى بيتحدث
var body: some View {
    let _ = print("Body recomputed!")
    
    return VStack {
        // المحتوى بتاعك
    }
}</code></pre>
      </div>
      
      <h4>القواعد الذهبية:</h4>
      <ul>
        <li>خلي الـ body خفيف وسريع</li>
        <li>استخدم IDs ثابتة دايماً</li>
        <li>تجنب AnyView إلا للضرورة</li>
        <li>استخدم Instruments لقياس الأداء</li>
        <li>احفظ النتائج المعقدة في @State</li>
      </ul>
      
      <p><span class="highlight">خلاصة:</span> فهم مشاكل الأداء دي هيخليك تكتب تطبيقات SwiftUI سريعة وسلسة!</p>
    </div>

    <a href="../SwiftUI_Interview_Questions.html" class="back-button">← العودة للأسئلة</a>
  </div>

  <footer>
    صفحة إجابة سؤال SwiftUI — الشرح بالعربي والإنجليزي
  </footer>
</body>

</html>