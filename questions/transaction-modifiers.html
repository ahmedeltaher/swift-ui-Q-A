<!DOCTYPE html>
<html lang="ar" dir="rtl">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transaction and TransactionModifiers in SwiftUI</title>
    
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-tomorrow.min.css" rel="stylesheet">
    
    <style>
      body {
        font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
        line-height: 1.6;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        direction: rtl;
      }
      .container {
        background: white;
        border-radius: 15px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        margin: 2rem auto;
        padding: 2rem;
        max-width: 1200px;
      }
      .question-title {
        color: #2c3e50;
        border-bottom: 3px solid #3498db;
        padding-bottom: 1rem;
        margin-bottom: 2rem;
        font-weight: 700;
      }
      .section-title {
        color: #e74c3c;
        margin: 2rem 0 1rem 0;
        font-weight: 600;
        font-size: 1.3rem;
      }
      .code-container {
        background: #2d3748;
        border-radius: 10px;
        padding: 1.5rem;
        margin: 1rem 0;
        overflow-x: auto;
      }
      .code-container code {
        color: #e2e8f0;
        font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
      }
      .highlight-box {
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
        padding: 1.5rem;
        border-radius: 10px;
        margin: 1.5rem 0;
      }
      .back-btn {
        background: linear-gradient(135deg, #667eea, #764ba2);
        border: none;
        color: white;
        padding: 0.7rem 1.5rem;
        border-radius: 25px;
        font-weight: 600;
        transition: transform 0.3s ease;
        text-decoration: none;
        display: inline-block;
        margin-bottom: 2rem;
      }
      .back-btn:hover {
        transform: translateY(-2px);
        color: white;
      }
      .concept-box {
        background: #f8f9fa;
        border-left: 4px solid #3498db;
        padding: 1rem 1.5rem;
        margin: 1rem 0;
        border-radius: 0 8px 8px 0;
      }
      .warning-box {
        background: #fff3cd;
        border-left: 4px solid #ffc107;
        padding: 1rem 1.5rem;
        margin: 1rem 0;
        border-radius: 0 8px 8px 0;
      }
      .success-box {
        background: #d1edff;
        border-left: 4px solid #17a2b8;
        padding: 1rem 1.5rem;
        margin: 1rem 0;
        border-radius: 0 8px 8px 0;
      }
      .transaction-flow {
        background: #e8f5e8;
        border: 2px solid #28a745;
        border-radius: 12px;
        padding: 1.5rem;
        margin: 1rem 0;
      }
      .modifier-chain {
        background: #f0f4ff;
        border: 2px solid #6366f1;
        border-radius: 12px;
        padding: 1.5rem;
        margin: 1rem 0;
      }
    </style>
  </head>

  <body>
    <div class="container">
      <a href="../SwiftUI_Interview_Questions.html" class="back-btn">
        â† Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„ØµÙØ­Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
      </a>

      <h1 class="question-title">
        How do Transaction and TransactionModifiers work in SwiftUI?
      </h1>

      <div class="highlight-box">
        <h4>âš¡ Ø§Ù„ÙÙƒØ±Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©</h4>
        <p>
          <strong>Transaction</strong> Ù‡Ùˆ Ø§Ù„Ù€ container Ø§Ù„Ù„ÙŠ Ø¨ÙŠØ­Ù…Ù„ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù€ animation state changes ÙÙŠ SwiftUI. 
          <strong>TransactionModifiers</strong> Ø¨ÙŠØ³Ù…Ø­ÙˆÙ„Ùƒ ØªØ¹Ø¯Ù„ ÙÙŠ Ø§Ù„Ù€ transaction Ù‚Ø¨Ù„ Ù…Ø§ ÙŠÙˆØµÙ„ Ù„Ù„Ù€ child viewsØŒ 
          ÙˆØ¯Ù‡ Ù…ÙÙŠØ¯ Ù„ØªØ®ØµÙŠØµ Ø§Ù„Ù€ animations Ø£Ùˆ Ù…Ù†Ø¹ animations ÙÙŠ Ø¨Ø¹Ø¶ Ø§Ù„Ø­Ø§Ù„Ø§Øª.
        </p>
      </div>

      <h2 class="section-title">ğŸ“ Ø§Ù„Ø´Ø±Ø­ Ø¨Ø§Ù„Ø¹Ø±Ø¨ÙŠ</h2>
      <p>
        ÙƒÙ„ Ù…Ø±Ø© ØªØ­ØµÙ„ state change ÙÙŠ SwiftUIØŒ Ø¨ÙŠØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Transaction object Ø§Ù„Ù„ÙŠ Ø¨ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ 
        animation details Ø²ÙŠ Ø§Ù„Ù€ duration ÙˆØ§Ù„Ù€ timing curve. TransactionModifiers Ø¨ØªØ®Ù„ÙŠÙƒ ØªØªØ­ÙƒÙ… 
        ÙÙŠ Ø§Ù„Ù€ transaction Ø¯Ù‡ Ù‚Ø¨Ù„ Ù…Ø§ ÙŠÙˆØµÙ„ Ù„Ù„Ù€ views Ø§Ù„ØªØ§Ù†ÙŠØ©ØŒ ÙØªÙ‚Ø¯Ø± ØªØºÙŠØ± Ø§Ù„Ù€ animation Ø£Ùˆ Ø­ØªÙ‰ ØªÙ…Ù†Ø¹Ù‡Ø§ Ø®Ø§Ù„Øµ.
      </p>

      <h2 class="section-title">ğŸ”„ Transaction Basics</h2>

      <div class="transaction-flow">
        <h5>ğŸ“Š Transaction Flow</h5>
        <p>State Change â†’ Transaction Creation â†’ Modifier Chain â†’ View Update â†’ Animation</p>
      </div>

      <div class="code-container">
        <pre><code class="language-swift">
import SwiftUI

// === Understanding Transaction Structure ===
struct TransactionBasicsView: View {
    @State private var isExpanded = false
    @State private var currentTransaction: Transaction?
    
    var body: some View {
        VStack(spacing: 30) {
            // Basic transaction info display
            VStack {
                Text("Transaction Monitor")
                    .font(.title2)
                    .fontWeight(.bold)
                
                if let transaction = currentTransaction {
                    VStack(alignment: .leading, spacing: 8) {
                        Text("Animation: \(transaction.animation?.description ?? "None")")
                        Text("Disabled: \(transaction.disablesAnimations ? "Yes" : "No")")
                        Text("Continuous: \(transaction.isContinuous ? "Yes" : "No")")
                    }
                    .padding()
                    .background(Color.blue.opacity(0.1))
                    .cornerRadius(8)
                } else {
                    Text("No active transaction")
                        .foregroundColor(.secondary)
                }
            }
            
            // Animated view that responds to transactions
            RoundedRectangle(cornerRadius: 20)
                .fill(isExpanded ? Color.green : Color.blue)
                .frame(
                    width: isExpanded ? 200 : 100,
                    height: isExpanded ? 200 : 100
                )
                .overlay(
                    Text(isExpanded ? "Expanded" : "Compact")
                        .foregroundColor(.white)
                        .fontWeight(.bold)
                )
            
            // Controls
            VStack(spacing: 15) {
                Button("Toggle with Default Animation") {
                    withAnimation {
                        isExpanded.toggle()
                    }
                }
                
                Button("Toggle with Custom Animation") {
                    withAnimation(.spring(duration: 2, bounce: 0.3)) {
                        isExpanded.toggle()
                    }
                }
                
                Button("Toggle without Animation") {
                    // No withAnimation wrapper
                    isExpanded.toggle()
                }
            }
        }
        .padding()
        // âœ… Monitor transaction changes
        .transaction { transaction in
            currentTransaction = transaction
            print("ğŸ“Š Transaction: \(transaction)")
        }
    }
}

// === Custom Transaction Modifier ===
struct CustomTransactionModifier: ViewModifier {
    let condition: Bool
    let customAnimation: Animation?
    
    func body(content: Content) -> some View {
        content
            .transaction { transaction in
                if condition {
                    // Override the animation
                    transaction.animation = customAnimation
                    print("ğŸ”„ Modified transaction animation")
                } else {
                    print("ğŸ”„ Transaction passed through unchanged")
                }
            }
    }
}

extension View {
    func customTransaction(when condition: Bool, animation: Animation?) -> some View {
        modifier(CustomTransactionModifier(condition: condition, customAnimation: animation))
    }
}

// === Transaction Inheritance Demo ===
struct TransactionInheritanceView: View {
    @State private var triggerAnimation = false
    
    var body: some View {
        VStack(spacing: 40) {
            Text("Transaction Inheritance")
                .font(.title)
                .fontWeight(.bold)
            
            // Parent animation affects all children
            VStack(spacing: 20) {
                ParentView(isAnimated: triggerAnimation)
            }
            .transaction { transaction in
                print("ğŸ¯ Root transaction: \(transaction.animation?.description ?? "None")")
            }
            
            Button("Trigger Animation") {
                withAnimation(.easeInOut(duration: 1.5)) {
                    triggerAnimation.toggle()
                }
            }
            .buttonStyle(.borderedProminent)
        }
        .padding()
    }
}

struct ParentView: View {
    let isAnimated: Bool
    
    var body: some View {
        VStack(spacing: 15) {
            Text("Parent View")
                .font(.headline)
                .padding()
                .background(isAnimated ? Color.orange : Color.gray)
                .foregroundColor(.white)
                .cornerRadius(8)
                .transaction { transaction in
                    print("ğŸ‘¨â€ğŸ‘¦ Parent transaction: \(transaction.animation?.description ?? "None")")
                }
            
            HStack(spacing: 15) {
                ChildView(isAnimated: isAnimated, id: "Child 1")
                ChildView(isAnimated: isAnimated, id: "Child 2")
            }
        }
        .padding()
        .background(Color.blue.opacity(0.2))
        .cornerRadius(12)
    }
}

struct ChildView: View {
    let isAnimated: Bool
    let id: String
    
    var body: some View {
        VStack {
            Text(id)
                .font(.caption)
                .fontWeight(.bold)
            
            Circle()
                .fill(isAnimated ? Color.red : Color.blue)
                .frame(width: isAnimated ? 50 : 30, height: isAnimated ? 50 : 30)
                .transaction { transaction in
                    print("ğŸ‘¶ \(id) transaction: \(transaction.animation?.description ?? "None")")
                }
        }
        .padding()
        .background(Color.white)
        .cornerRadius(8)
    }
}

// === Transaction Debugging Helper ===
struct TransactionDebugger: ViewModifier {
    let label: String
    
    func body(content: Content) -> some View {
        content
            .transaction { transaction in
                print("ğŸ› [\(label)] Transaction Debug:")
                print("   Animation: \(transaction.animation?.description ?? "None")")
                print("   Disabled: \(transaction.disablesAnimations)")
                print("   Continuous: \(transaction.isContinuous)")
                print("   ----")
            }
    }
}

extension View {
    func debugTransaction(_ label: String) -> some View {
        modifier(TransactionDebugger(label: label))
    }
}

// === Understanding Transaction Timing ===
struct TransactionTimingView: View {
    @State private var progress: Double = 0
    @State private var isRunning = false
    
    var body: some View {
        VStack(spacing: 30) {
            Text("Transaction Timing")
                .font(.title)
                .fontWeight(.bold)
            
            // Progress indicator
            VStack {
                ProgressView(value: progress)
                    .progressViewStyle(LinearProgressViewStyle())
                    .scaleEffect(y: 4)
                
                Text("\(Int(progress * 100))%")
                    .font(.title2)
                    .fontWeight(.bold)
                    .padding(.top)
            }
            .debugTransaction("ProgressView")
            
            // Control buttons
            HStack(spacing: 20) {
                Button("Fast Animation") {
                    startAnimation(.easeInOut(duration: 0.5))
                }
                
                Button("Medium Animation") {
                    startAnimation(.easeInOut(duration: 2.0))
                }
                
                Button("Slow Animation") {
                    startAnimation(.easeInOut(duration: 5.0))
                }
            }
            
            Button("Reset") {
                withAnimation(.easeInOut(duration: 0.3)) {
                    progress = 0
                    isRunning = false
                }
            }
            .buttonStyle(.borderedProminent)
        }
        .padding()
    }
    
    private func startAnimation(_ animation: Animation) {
        withAnimation(animation) {
            progress = 1.0
            isRunning = true
        }
    }
}
</code></pre>
      </div>

      <h2 class="section-title">ğŸ› ï¸ Advanced Transaction Modifiers</h2>

      <div class="modifier-chain">
        <h5>ğŸ”— Transaction Modifier Chain</h5>
        <p>View â†’ Transaction Modifier 1 â†’ Transaction Modifier 2 â†’ Child Views</p>
      </div>

      <div class="code-container">
        <pre><code class="language-swift">
import SwiftUI

// === Conditional Animation Modifier ===
struct ConditionalAnimationView: View {
    @State private var isLargeSize = false
    @State private var isHighPerformanceMode = false
    @State private var animationCount = 0
    
    var body: some View {
        VStack(spacing: 30) {
            Text("Conditional Animation Control")
                .font(.title2)
                .fontWeight(.bold)
            
            // Performance mode toggle
            VStack {
                Toggle("High Performance Mode", isOn: $isHighPerformanceMode)
                    .padding()
                    .background(Color.gray.opacity(0.1))
                    .cornerRadius(8)
                
                Text(isHighPerformanceMode ? "ğŸš€ Animations Disabled for Performance" : "âœ¨ Animations Enabled")
                    .font(.caption)
                    .foregroundColor(isHighPerformanceMode ? .orange : .green)
            }
            
            // Animated element
            RoundedRectangle(cornerRadius: 20)
                .fill(LinearGradient(
                    gradient: Gradient(colors: [.blue, .purple]),
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                ))
                .frame(
                    width: isLargeSize ? 250 : 150,
                    height: isLargeSize ? 250 : 150
                )
                .overlay(
                    VStack {
                        Text("Tap to Resize")
                            .foregroundColor(.white)
                            .fontWeight(.bold)
                        
                        Text("Animations: \(animationCount)")
                            .foregroundColor(.white.opacity(0.8))
                            .font(.caption)
                    }
                )
                .onTapGesture {
                    withAnimation(.spring(duration: 0.8, bounce: 0.4)) {
                        isLargeSize.toggle()
                    }
                }
                // âœ… Conditional animation control
                .transaction { transaction in
                    if isHighPerformanceMode {
                        // Disable animations in performance mode
                        transaction.disablesAnimations = true
                        print("ğŸš« Animation disabled for performance")
                    } else {
                        animationCount += 1
                        print("âœ… Animation allowed: #\(animationCount)")
                    }
                }
            
            Text("Total Animation Count: \(animationCount)")
                .font(.headline)
                .padding()
                .background(Color.blue.opacity(0.1))
                .cornerRadius(8)
        }
        .padding()
    }
}

// === Animation Chaining with Transactions ===
struct AnimationChainingView: View {
    @State private var step = 0
    @State private var isChainRunning = false
    
    private let totalSteps = 5
    
    var body: some View {
        VStack(spacing: 40) {
            Text("Animation Chaining")
                .font(.title2)
                .fontWeight(.bold)
            
            // Step indicator
            HStack {
                ForEach(0..<totalSteps, id: \.self) { index in
                    Circle()
                        .fill(index <= step ? Color.green : Color.gray.opacity(0.3))
                        .frame(width: 20, height: 20)
                        .scaleEffect(index == step ? 1.3 : 1.0)
                }
            }
            .padding()
            
            // Animated elements for each step
            VStack(spacing: 20) {
                StepView(stepNumber: 0, currentStep: step, label: "Initialize")
                StepView(stepNumber: 1, currentStep: step, label: "Load Data")
                StepView(stepNumber: 2, currentStep: step, label: "Process")
                StepView(stepNumber: 3, currentStep: step, label: "Validate")
                StepView(stepNumber: 4, currentStep: step, label: "Complete")
            }
            
            Button(isChainRunning ? "Running..." : "Start Chain") {
                if !isChainRunning {
                    startAnimationChain()
                }
            }
            .buttonStyle(.borderedProminent)
            .disabled(isChainRunning)
        }
        .padding()
    }
    
    private func startAnimationChain() {
        isChainRunning = true
        step = 0
        
        // Chain animations with different timing
        animateStep(0, delay: 0, duration: 0.5) {
            animateStep(1, delay: 0.2, duration: 0.6) {
                animateStep(2, delay: 0.3, duration: 0.8) {
                    animateStep(3, delay: 0.2, duration: 0.5) {
                        animateStep(4, delay: 0.1, duration: 0.4) {
                            isChainRunning = false
                        }
                    }
                }
            }
        }
    }
    
    private func animateStep(_ stepNumber: Int, delay: Double, duration: Double, completion: @escaping () -> Void) {
        DispatchQueue.main.asyncAfter(deadline: .now() + delay) {
            withAnimation(.easeInOut(duration: duration)) {
                step = stepNumber
            }
            
            // Schedule next step
            DispatchQueue.main.asyncAfter(deadline: .now() + duration) {
                completion()
            }
        }
    }
}

struct StepView: View {
    let stepNumber: Int
    let currentStep: Int
    let label: String
    
    var isActive: Bool {
        currentStep >= stepNumber
    }
    
    var isCurrentStep: Bool {
        currentStep == stepNumber
    }
    
    var body: some View {
        HStack {
            Circle()
                .fill(isActive ? Color.blue : Color.gray.opacity(0.3))
                .frame(width: 40, height: 40)
                .overlay(
                    Text("\(stepNumber + 1)")
                        .foregroundColor(.white)
                        .fontWeight(.bold)
                )
                .scaleEffect(isCurrentStep ? 1.2 : 1.0)
            
            Text(label)
                .font(.headline)
                .foregroundColor(isActive ? .primary : .secondary)
            
            Spacer()
            
            if isActive {
                Image(systemName: "checkmark")
                    .foregroundColor(.green)
                    .fontWeight(.bold)
            }
        }
        .padding()
        .background(isCurrentStep ? Color.blue.opacity(0.1) : Color.clear)
        .cornerRadius(8)
        // âœ… Step-specific transaction handling
        .transaction { transaction in
            if isCurrentStep {
                // Enhance animation for current step
                transaction.animation = .spring(duration: 0.6, bounce: 0.3)
            }
        }
    }
}

// === Custom Animation Modifier with Transaction ===
struct CustomAnimationModifier: ViewModifier {
    let animationType: AnimationType
    let isEnabled: Bool
    
    enum AnimationType {
        case bounce
        case smooth
        case spring
        case instant
        
        var animation: Animation? {
            switch self {
            case .bounce:
                return .spring(duration: 0.8, bounce: 0.6)
            case .smooth:
                return .easeInOut(duration: 0.6)
            case .spring:
                return .spring(duration: 1.0, bounce: 0.3)
            case .instant:
                return nil
            }
        }
    }
    
    func body(content: Content) -> some View {
        content
            .transaction { transaction in
                if isEnabled {
                    transaction.animation = animationType.animation
                    print("ğŸ¨ Applied \(animationType) animation")
                } else {
                    transaction.disablesAnimations = true
                    print("ğŸš« Animations disabled")
                }
            }
    }
}

extension View {
    func customAnimation(_ type: CustomAnimationModifier.AnimationType, enabled: Bool = true) -> some View {
        modifier(CustomAnimationModifier(animationType: type, isEnabled: enabled))
    }
}

// === Complex Transaction Demo ===
struct ComplexTransactionDemo: View {
    @State private var configuration = AnimationConfiguration()
    @State private var isAnimating = false
    
    struct AnimationConfiguration {
        var enableBounce = true
        var enableGlow = true
        var enableRotation = true
        var speed: Double = 1.0
        var intensity: Double = 1.0
    }
    
    var body: some View {
        ScrollView {
            VStack(spacing: 30) {
                Text("Complex Transaction Demo")
                    .font(.title)
                    .fontWeight(.bold)
                
                // Configuration controls
                ConfigurationPanel(configuration: $configuration)
                
                // Animated demo element
                AnimatedDemoElement(
                    configuration: configuration,
                    isAnimating: $isAnimating
                )
                
                // Control buttons
                HStack(spacing: 20) {
                    Button("Start Animation") {
                        withAnimation {
                            isAnimating = true
                        }
                    }
                    .disabled(isAnimating)
                    
                    Button("Stop Animation") {
                        withAnimation {
                            isAnimating = false
                        }
                    }
                    .disabled(!isAnimating)
                }
                .buttonStyle(.borderedProminent)
            }
            .padding()
        }
    }
}

struct ConfigurationPanel: View {
    @Binding var configuration: ComplexTransactionDemo.AnimationConfiguration
    
    var body: some View {
        VStack(spacing: 15) {
            Text("Animation Configuration")
                .font(.headline)
            
            VStack(spacing: 10) {
                Toggle("Enable Bounce", isOn: $configuration.enableBounce)
                Toggle("Enable Glow", isOn: $configuration.enableGlow)
                Toggle("Enable Rotation", isOn: $configuration.enableRotation)
                
                VStack {
                    Text("Speed: \(configuration.speed, specifier: "%.1f")x")
                    Slider(value: $configuration.speed, in: 0.1...3.0)
                }
                
                VStack {
                    Text("Intensity: \(configuration.intensity, specifier: "%.1f")x")
                    Slider(value: $configuration.intensity, in: 0.1...2.0)
                }
            }
        }
        .padding()
        .background(Color.gray.opacity(0.1))
        .cornerRadius(12)
    }
}

struct AnimatedDemoElement: View {
    let configuration: ComplexTransactionDemo.AnimationConfiguration
    @Binding var isAnimating: Bool
    @State private var rotationAngle: Double = 0
    @State private var glowIntensity: Double = 0
    
    var body: some View {
        ZStack {
            // Glow effect
            if configuration.enableGlow {
                Circle()
                    .fill(
                        RadialGradient(
                            gradient: Gradient(colors: [
                                .blue.opacity(glowIntensity * configuration.intensity),
                                .clear
                            ]),
                            center: .center,
                            startRadius: 0,
                            endRadius: 100
                        )
                    )
                    .frame(width: 200, height: 200)
                    .blur(radius: 10)
            }
            
            // Main element
            RoundedRectangle(cornerRadius: 25)
                .fill(
                    LinearGradient(
                        gradient: Gradient(colors: [.purple, .blue]),
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
                .frame(width: 150, height: 150)
                .rotationEffect(.degrees(configuration.enableRotation ? rotationAngle : 0))
                .scaleEffect(configuration.enableBounce && isAnimating ? 1.2 : 1.0)
                .overlay(
                    Text("Demo")
                        .foregroundColor(.white)
                        .fontWeight(.bold)
                        .font(.title2)
                )
        }
        // âœ… Complex transaction handling
        .transaction { transaction in
            var modifiedAnimation: Animation?
            
            if configuration.enableBounce {
                modifiedAnimation = .spring(
                    duration: 1.0 / configuration.speed,
                    bounce: 0.4 * configuration.intensity
                )
            } else {
                modifiedAnimation = .easeInOut(duration: 0.8 / configuration.speed)
            }
            
            transaction.animation = modifiedAnimation
            
            print("ğŸ”„ Transaction modified with configuration:")
            print("   Bounce: \(configuration.enableBounce)")
            print("   Speed: \(configuration.speed)")
            print("   Intensity: \(configuration.intensity)")
        }
        .onChange(of: isAnimating) { _, newValue in
            if newValue {
                startContinuousAnimations()
            }
        }
    }
    
    private func startContinuousAnimations() {
        if configuration.enableRotation && isAnimating {
            withAnimation(.linear(duration: 3.0 / configuration.speed).repeatForever(autoreverses: false)) {
                rotationAngle = 360
            }
        }
        
        if configuration.enableGlow && isAnimating {
            withAnimation(.easeInOut(duration: 2.0 / configuration.speed).repeatForever(autoreverses: true)) {
                glowIntensity = 0.8
            }
        }
    }
}

// === Transaction Performance Monitor ===
struct TransactionPerformanceView: View {
    @StateObject private var monitor = TransactionMonitor()
    @State private var triggerUpdates = false
    
    var body: some View {
        VStack(spacing: 20) {
            Text("Transaction Performance")
                .font(.title)
                .fontWeight(.bold)
            
            // Performance metrics
            PerformanceMetricsView(monitor: monitor)
            
            // Test elements
            LazyVGrid(columns: Array(repeating: GridItem(.flexible()), count: 3), spacing: 20) {
                ForEach(0..<9, id: \.self) { index in
                    MonitoredElement(
                        index: index,
                        isActive: triggerUpdates,
                        monitor: monitor
                    )
                }
            }
            
            Button("Trigger Mass Update") {
                withAnimation(.spring(duration: 1.0, bounce: 0.3)) {
                    triggerUpdates.toggle()
                }
            }
            .buttonStyle(.borderedProminent)
        }
        .padding()
    }
}

@MainActor
class TransactionMonitor: ObservableObject {
    @Published var transactionCount = 0
    @Published var averageProcessingTime: Double = 0
    @Published var lastUpdate = Date()
    
    private var processingTimes: [Double] = []
    
    func recordTransaction(processingTime: Double) {
        transactionCount += 1
        processingTimes.append(processingTime)
        lastUpdate = Date()
        
        // Keep only last 50 measurements
        if processingTimes.count > 50 {
            processingTimes.removeFirst()
        }
        
        averageProcessingTime = processingTimes.reduce(0, +) / Double(processingTimes.count)
    }
}

struct PerformanceMetricsView: View {
    @ObservedObject let monitor: TransactionMonitor
    
    var body: some View {
        HStack {
            VStack {
                Text("\(monitor.transactionCount)")
                    .font(.title2)
                    .fontWeight(.bold)
                Text("Transactions")
                    .font(.caption)
            }
            
            Spacer()
            
            VStack {
                Text("\(monitor.averageProcessingTime * 1000, specifier: "%.2f")ms")
                    .font(.title2)
                    .fontWeight(.bold)
                    .foregroundColor(monitor.averageProcessingTime > 0.016 ? .red : .green)
                Text("Avg Time")
                    .font(.caption)
            }
        }
        .padding()
        .background(Color.gray.opacity(0.1))
        .cornerRadius(8)
    }
}

struct MonitoredElement: View {
    let index: Int
    let isActive: Bool
    let monitor: TransactionMonitor
    
    var body: some View {
        let startTime = CFAbsoluteTimeGetCurrent()
        
        return RoundedRectangle(cornerRadius: 12)
            .fill(isActive ? Color.green : Color.blue)
            .frame(height: 80)
            .overlay(
                Text("\(index + 1)")
                    .foregroundColor(.white)
                    .fontWeight(.bold)
            )
            .scaleEffect(isActive ? 1.1 : 1.0)
            .transaction { transaction in
                let endTime = CFAbsoluteTimeGetCurrent()
                let processingTime = endTime - startTime
                
                monitor.recordTransaction(processingTime: processingTime)
                
                // Add slight variation to animation timing
                if let animation = transaction.animation {
                    let delay = Double(index) * 0.05 // Stagger animations
                    transaction.animation = animation.delay(delay)
                }
            }
    }
}
</code></pre>
      </div>

      <h2 class="section-title">ğŸ¯ Real-World Use Cases</h2>

      <div class="success-box">
        <h5>ğŸ’¡ Practical Applications</h5>
        <p>Ø­Ø§Ù„Ø§Øª Ø­Ù‚ÙŠÙ‚ÙŠØ© Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Transaction ÙˆØ§Ù„Ù€ TransactionModifiers ÙÙŠ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚Ø§Øª</p>
      </div>

      <div class="code-container">
        <pre><code class="language-swift">
import SwiftUI

// === USE CASE 1: Accessibility-Aware Animations ===
struct AccessibilityAwareView: View {
    @State private var isExpanded = false
    @Environment(\.accessibilityReduceMotion) private var reduceMotion
    
    var body: some View {
        VStack(spacing: 30) {
            Text("Accessibility-Aware Animations")
                .font(.title2)
                .fontWeight(.bold)
            
            Text(reduceMotion ? "ğŸš« Motion Reduced (Accessibility)" : "âœ¨ Motion Enabled")
                .foregroundColor(reduceMotion ? .orange : .green)
                .padding()
                .background(Color.gray.opacity(0.1))
                .cornerRadius(8)
            
            // Content that respects accessibility settings
            ExpandableCard(
                title: "Sample Card",
                content: "This card respects accessibility settings and will disable animations when reduce motion is enabled.",
                isExpanded: $isExpanded
            )
            
            Button(isExpanded ? "Collapse" : "Expand") {
                withAnimation {
                    isExpanded.toggle()
                }
            }
            .buttonStyle(.borderedProminent)
        }
        .padding()
    }
}

struct ExpandableCard: View {
    let title: String
    let content: String
    @Binding var isExpanded: Bool
    @Environment(\.accessibilityReduceMotion) private var reduceMotion
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text(title)
                .font(.headline)
                .fontWeight(.bold)
            
            if isExpanded {
                Text(content)
                    .font(.body)
                    .transition(.opacity.combined(with: .scale))
            }
        }
        .frame(maxWidth: .infinity, alignment: .leading)
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color.blue.opacity(0.1))
                .frame(height: isExpanded ? nil : 80)
        )
        // âœ… Respect accessibility preferences
        .transaction { transaction in
            if reduceMotion {
                transaction.disablesAnimations = true
                print("â™¿ Animations disabled for accessibility")
            } else {
                transaction.animation = .spring(duration: 0.6, bounce: 0.2)
                print("âœ¨ Animations enabled")
            }
        }
    }
}

// === USE CASE 2: Performance-Based Animation Control ===
struct PerformanceBasedAnimationView: View {
    @StateObject private var performanceManager = PerformanceManager()
    @State private var items: [PerformanceItem] = []
    
    var body: some View {
        NavigationView {
            VStack {
                // Performance indicator
                PerformanceIndicator(manager: performanceManager)
                
                // List with performance-aware animations
                List(items) { item in
                    PerformanceAwareRow(
                        item: item,
                        performanceMode: performanceManager.currentMode
                    )
                }
                .transaction { transaction in
                    // Adjust animations based on performance
                    switch performanceManager.currentMode {
                    case .highPerformance:
                        transaction.disablesAnimations = true
                    case .balanced:
                        transaction.animation = .easeInOut(duration: 0.3)
                    case .smooth:
                        transaction.animation = .spring(duration: 0.8, bounce: 0.4)
                    }
                }
            }
            .navigationTitle("Performance Aware")
            .onAppear {
                loadItems()
                performanceManager.startMonitoring()
            }
        }
    }
    
    private func loadItems() {
        items = (1...100).map { index in
            PerformanceItem(
                id: UUID(),
                title: "Item \(index)",
                subtitle: "Performance-aware item"
            )
        }
    }
}

@MainActor
class PerformanceManager: ObservableObject {
    @Published var currentMode: PerformanceMode = .balanced
    @Published var frameRate: Double = 60.0
    @Published var memoryUsage: Double = 50.0
    
    enum PerformanceMode {
        case highPerformance  // Minimal animations
        case balanced        // Some animations
        case smooth         // Full animations
    }
    
    private var displayLink: CADisplayLink?
    private var lastFrameTimestamp: CFTimeInterval = 0
    
    func startMonitoring() {
        displayLink = CADisplayLink(target: self, selector: #selector(updatePerformanceMetrics))
        displayLink?.add(to: .main, forMode: .common)
    }
    
    @objc private func updatePerformanceMetrics() {
        let currentTime = CACurrentMediaTime()
        
        if lastFrameTimestamp > 0 {
            let frameDuration = currentTime - lastFrameTimestamp
            frameRate = 1.0 / frameDuration
            
            // Simulate memory usage
            memoryUsage = Double.random(in: 30...90)
            
            // Adjust performance mode based on metrics
            updatePerformanceMode()
        }
        
        lastFrameTimestamp = currentTime
    }
    
    private func updatePerformanceMode() {
        let newMode: PerformanceMode
        
        if frameRate < 30 || memoryUsage > 80 {
            newMode = .highPerformance
        } else if frameRate < 50 || memoryUsage > 60 {
            newMode = .balanced
        } else {
            newMode = .smooth
        }
        
        if newMode != currentMode {
            currentMode = newMode
            print("ğŸ¯ Performance mode changed to: \(newMode)")
        }
    }
    
    deinit {
        displayLink?.invalidate()
    }
}

struct PerformanceItem: Identifiable {
    let id: UUID
    let title: String
    let subtitle: String
}

struct PerformanceIndicator: View {
    @ObservedObject let manager: PerformanceManager
    
    var body: some View {
        HStack {
            VStack {
                Text("\(Int(manager.frameRate))")
                    .font(.title2)
                    .fontWeight(.bold)
                    .foregroundColor(frameRateColor)
                Text("FPS")
                    .font(.caption)
            }
            
            Spacer()
            
            VStack {
                Text("\(Int(manager.memoryUsage))%")
                    .font(.title2)
                    .fontWeight(.bold)
                    .foregroundColor(memoryColor)
                Text("Memory")
                    .font(.caption)
            }
            
            Spacer()
            
            VStack {
                Text(modeText)
                    .font(.title2)
                    .fontWeight(.bold)
                    .foregroundColor(modeColor)
                Text("Mode")
                    .font(.caption)
            }
        }
        .padding()
        .background(Color.gray.opacity(0.1))
        .cornerRadius(12)
        .padding(.horizontal)
    }
    
    private var frameRateColor: Color {
        manager.frameRate >= 50 ? .green : manager.frameRate >= 30 ? .orange : .red
    }
    
    private var memoryColor: Color {
        manager.memoryUsage <= 60 ? .green : manager.memoryUsage <= 80 ? .orange : .red
    }
    
    private var modeText: String {
        switch manager.currentMode {
        case .highPerformance: return "ğŸš€"
        case .balanced: return "âš–ï¸"
        case .smooth: return "âœ¨"
        }
    }
    
    private var modeColor: Color {
        switch manager.currentMode {
        case .highPerformance: return .red
        case .balanced: return .orange
        case .smooth: return .green
        }
    }
}

struct PerformanceAwareRow: View {
    let item: PerformanceItem
    let performanceMode: PerformanceManager.PerformanceMode
    @State private var isHighlighted = false
    
    var body: some View {
        HStack {
            VStack(alignment: .leading) {
                Text(item.title)
                    .font(.headline)
                
                Text(item.subtitle)
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            
            Spacer()
            
            // Visual indicator based on performance mode
            performanceModeIndicator
        }
        .padding(.vertical, 4)
        .background(isHighlighted ? Color.blue.opacity(0.1) : Color.clear)
        .onTapGesture {
            withAnimation {
                isHighlighted.toggle()
            }
        }
    }
    
    @ViewBuilder
    private var performanceModeIndicator: some View {
        switch performanceMode {
        case .highPerformance:
            Circle()
                .fill(Color.red)
                .frame(width: 12, height: 12)
        case .balanced:
            Circle()
                .fill(Color.orange)
                .frame(width: 16, height: 16)
        case .smooth:
            Circle()
                .fill(Color.green)
                .frame(width: 20, height: 20)
                .overlay(
                    Circle()
                        .stroke(Color.green.opacity(0.3), lineWidth: 4)
                        .scaleEffect(isHighlighted ? 1.5 : 1.0)
                )
        }
    }
}

// === USE CASE 3: Context-Aware Animations ===
struct ContextAwareAnimationView: View {
    @State private var context: AnimationContext = .normal
    @State private var isPlaying = false
    
    enum AnimationContext {
        case normal
        case gaming
        case presentation
        case accessibility
        
        var animationStyle: Animation? {
            switch self {
            case .normal:
                return .easeInOut(duration: 0.5)
            case .gaming:
                return .linear(duration: 0.2)
            case .presentation:
                return .spring(duration: 1.2, bounce: 0.3)
            case .accessibility:
                return nil // No animations
            }
        }
        
        var description: String {
            switch self {
            case .normal: return "ğŸ  Normal Mode"
            case .gaming: return "ğŸ® Gaming Mode"
            case .presentation: return "ğŸ“Š Presentation Mode"
            case .accessibility: return "â™¿ Accessibility Mode"
            }
        }
    }
    
    var body: some View {
        VStack(spacing: 30) {
            Text("Context-Aware Animations")
                .font(.title)
                .fontWeight(.bold)
            
            // Context selector
            VStack {
                Text("Current Context:")
                Text(context.description)
                    .font(.headline)
                    .foregroundColor(.blue)
                
                Picker("Context", selection: $context) {
                    ForEach([AnimationContext.normal, .gaming, .presentation, .accessibility], id: \.self) { ctx in
                        Text(ctx.description).tag(ctx)
                    }
                }
                .pickerStyle(.segmented)
            }
            .padding()
            .background(Color.gray.opacity(0.1))
            .cornerRadius(12)
            
            // Demo animation element
            RoundedRectangle(cornerRadius: 20)
                .fill(LinearGradient(
                    gradient: Gradient(colors: [.purple, .blue]),
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                ))
                .frame(width: isPlaying ? 200 : 100, height: isPlaying ? 200 : 100)
                .rotationEffect(.degrees(isPlaying ? 360 : 0))
                .overlay(
                    Text(isPlaying ? "Playing" : "Stopped")
                        .foregroundColor(.white)
                        .fontWeight(.bold)
                )
                // âœ… Context-aware transaction handling
                .transaction { transaction in
                    transaction.animation = context.animationStyle
                    
                    print("ğŸ¯ Context: \(context)")
                    print("ğŸ¨ Animation: \(transaction.animation?.description ?? "None")")
                }
            
            Button(isPlaying ? "Stop" : "Play") {
                withAnimation {
                    isPlaying.toggle()
                }
            }
            .buttonStyle(.borderedProminent)
        }
        .padding()
    }
}
</code></pre>
      </div>

      <h2 class="section-title">ğŸ¯ Best Practices & Guidelines</h2>

      <div class="highlight-box">
        <h4>ğŸ“‹ Transaction Best Practices</h4>
        <div>
          <h5>âœ… Do:</h5>
          <ul>
            <li><strong>Monitor Performance:</strong> Ø§Ø³ØªØ®Ø¯Ù… transaction modifiers Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ø£Ø¯Ø§Ø¡</li>
            <li><strong>Respect Accessibility:</strong> Ø§Ø¹Ù…Ù„ disable Ù„Ù„Ù€ animations Ù„Ù…Ø§ reduce motion Ù…ÙØ¹Ù„</li>
            <li><strong>Context Awareness:</strong> ØºÙŠØ± Ø§Ù„Ù€ animations Ø­Ø³Ø¨ Ø§Ù„Ù€ context</li>
            <li><strong>Chain Carefully:</strong> Ø®Ø¯ Ø¨Ø§Ù„Ùƒ Ù…Ù† Ø§Ù„Ù€ transaction modifier order</li>
          </ul>
          
          <h5>ğŸš« Don't:</h5>
          <ul>
            <li><strong>Override Blindly:</strong> Ù…ØªØºÙŠØ±Ø´ ÙƒÙ„ transaction Ø¨Ù„Ø§ Ø¯Ø§Ø¹ÙŠ</li>
            <li><strong>Ignore Performance:</strong> Ù…ØªØ±Ø£ÙƒØ´ Ø§Ù„Ù€ frame rate ÙˆØ§Ù„Ù€ memory usage</li>
            <li><strong>Complex Logic:</strong> Ù…ØªØ­Ø·Ø´ logic Ù…Ø¹Ù‚Ø¯ ÙÙŠ Ø§Ù„Ù€ transaction modifier</li>
            <li><strong>Nested Transactions:</strong> ØªØ¬Ù†Ø¨ Ø§Ù„Ù€ deeply nested transaction modifications</li>
          </ul>
        </div>
      </div>

      <h2 class="section-title">ğŸ“Š Ø§Ù„Ø®Ù„Ø§ØµØ©</h2>

      <div class="concept-box">
        <p>
          <strong>Transaction Ùˆ TransactionModifiers Summary:</strong>
        </p>
        <ul>
          <li><strong>Transaction:</strong> Ø¨ÙŠØ­Ù…Ù„ animation state Ùˆmeta-data Ù„Ù„Ù€ view updates</li>
          <li><strong>TransactionModifiers:</strong> Ø¨ÙŠØ³Ù…Ø­ÙˆÙ„Ùƒ ØªØ¹Ø¯Ù„ ÙÙŠ Ø§Ù„Ù€ transaction Ù‚Ø¨Ù„ Ù…Ø§ ÙŠÙˆØµÙ„ Ù„Ù„Ù€ children</li>
          <li><strong>Performance Control:</strong> Ù…ÙÙŠØ¯ Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø£Ø¯Ø§Ø¡ ÙˆØ¥ÙŠÙ‚Ø§Ù Ø§Ù„Ù€ animations Ù„Ù…Ø§ Ù„Ø§Ø²Ù…</li>
          <li><strong>Accessibility:</strong> essential Ù„Ø¯Ø¹Ù… accessibility features Ø²ÙŠ reduce motion</li>
          <li><strong>Context Awareness:</strong> ÙŠØ®Ù„ÙŠÙƒ ØªØ®ØµØµ Ø§Ù„Ù€ animations Ø­Ø³Ø¨ Ø§Ù„Ù€ app context</li>
          <li><strong>Debugging Tool:</strong> Ù…Ù…ØªØ§Ø² Ù„Ù€ debugging animation issues ÙˆØ§Ù„Ù€ performance problems</li>
        </ul>
      </div>

      <div class="mt-4">
        <a href="../SwiftUI_Interview_Questions.html" class="back-btn">
          â† Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
        </a>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/autoloader/prism-autoloader.min.js"></script>
  </body>
</html>