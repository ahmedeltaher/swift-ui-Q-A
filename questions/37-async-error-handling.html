<!DOCTYPE html>
<html lang="ar" dir="rtl">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Async Error Handling in SwiftUI</title>
    
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-tomorrow.min.css" rel="stylesheet">
    
    <style>
      body {
        font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
        line-height: 1.6;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        direction: rtl;
      }
      .container {
        background: white;
        border-radius: 15px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        margin: 2rem auto;
        padding: 2rem;
        max-width: 1200px;
      }
      .question-title {
        color: #2c3e50;
        border-bottom: 3px solid #3498db;
        padding-bottom: 1rem;
        margin-bottom: 2rem;
        font-weight: 700;
      }
      .section-title {
        color: #e74c3c;
        margin: 2rem 0 1rem 0;
        font-weight: 600;
        font-size: 1.3rem;
      }
      .code-container {
        background: #2d3748;
        border-radius: 10px;
        padding: 1.5rem;
        margin: 1rem 0;
        overflow-x: auto;
      }
      .code-container code {
        color: #e2e8f0;
        font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
      }
      .highlight-box {
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
        padding: 1.5rem;
        border-radius: 10px;
        margin: 1.5rem 0;
      }
      .back-btn {
        background: linear-gradient(135deg, #667eea, #764ba2);
        border: none;
        color: white;
        padding: 0.7rem 1.5rem;
        border-radius: 25px;
        font-weight: 600;
        transition: transform 0.3s ease;
        text-decoration: none;
        display: inline-block;
        margin-bottom: 2rem;
      }
      .back-btn:hover {
        transform: translateY(-2px);
        color: white;
      }
      .concept-box {
        background: #f8f9fa;
        border-left: 4px solid #3498db;
        padding: 1rem 1.5rem;
        margin: 1rem 0;
        border-radius: 0 8px 8px 0;
      }
      .warning-box {
        background: #fff3cd;
        border-left: 4px solid #ffc107;
        padding: 1rem 1.5rem;
        margin: 1rem 0;
        border-radius: 0 8px 8px 0;
      }
      .success-box {
        background: #d1edff;
        border-left: 4px solid #17a2b8;
        padding: 1rem 1.5rem;
        margin: 1rem 0;
        border-radius: 0 8px 8px 0;
      }
      .error-box {
        background: #f8d7da;
        border-left: 4px solid #dc3545;
        padding: 1rem 1.5rem;
        margin: 1rem 0;
        border-radius: 0 8px 8px 0;
      }
    </style>
  </head>

  <body>
    <div class="container">
      <a href="../SwiftUI_Interview_Questions.html" class="back-btn">
        ← العودة للصفحة الرئيسية
      </a>

      <h1 class="question-title">
        How do you handle errors in SwiftUI with async/await?
      </h1>

      <div class="highlight-box">
        <h4>⚠️ الفكرة الأساسية</h4>
        <p>
          <strong>Error Handling</strong> مع async/await في SwiftUI بيتطلب طرق مختلفة لالتقاط الـ errors 
          وعرضها للمستخدم بطريقة مناسبة. من try-catch البسيط للـ Result types المتقدمة.
        </p>
      </div>

      <h2 class="section-title">📝 الشرح بالعربي</h2>
      <p>
        التعامل مع الأخطاء في async operations أمر ضروري لأي تطبيق حقيقي. 
        SwiftUI مع async/await بيوفر طرق مختلفة للتعامل مع الأخطاء، 
        من الـ basic try-catch للـ advanced error recovery patterns.
      </p>

      <h2 class="section-title">🎯 Basic Error Handling with try-catch</h2>

      <div class="success-box">
        <h5>1. Simple Error Handling</h5>
        <p>الطريقة الأساسية للتعامل مع الأخطاء في async functions</p>
      </div>

      <div class="code-container">
        <pre><code class="language-swift">
@MainActor
class BasicErrorHandlingViewModel: ObservableObject {
    @Published var users: [User] = []
    @Published var isLoading = false
    @Published var errorMessage: String?
    
    func fetchUsers() async {
        isLoading = true
        errorMessage = nil
        
        do {
            let fetchedUsers = try await APIService.shared.fetchUsers()
            users = fetchedUsers
        } catch {
            errorMessage = error.localizedDescription
            print("Error fetching users: \(error)")
        }
        
        isLoading = false
    }
}

struct BasicErrorHandlingView: View {
    @StateObject private var viewModel = BasicErrorHandlingViewModel()
    
    var body: some View {
        NavigationView {
            VStack {
                if let errorMessage = viewModel.errorMessage {
                    ErrorBanner(
                        message: errorMessage,
                        onRetry: {
                            Task {
                                await viewModel.fetchUsers()
                            }
                        }
                    )
                }
                
                if viewModel.isLoading {
                    ProgressView("Loading users...")
                        .frame(maxWidth: .infinity, maxHeight: .infinity)
                } else {
                    List(viewModel.users) { user in
                        UserRowView(user: user)
                    }
                }
            }
            .navigationTitle("Users")
            .task {
                await viewModel.fetchUsers()
            }
        }
    }
}

struct ErrorBanner: View {
    let message: String
    let onRetry: () -> Void
    
    var body: some View {
        HStack {
            Image(systemName: "exclamationmark.triangle.fill")
                .foregroundColor(.red)
            
            VStack(alignment: .leading) {
                Text("Error")
                    .font(.headline)
                Text(message)
                    .font(.caption)
            }
            
            Spacer()
            
            Button("Retry", action: onRetry)
                .buttonStyle(.borderedProminent)
        }
        .padding()
        .background(Color.red.opacity(0.1))
        .cornerRadius(8)
        .padding(.horizontal)
    }
}
</code></pre>
      </div>

      <h2 class="section-title">⚡ Advanced Error Handling with Result Type</h2>

      <div class="concept-box">
        <h5>استخدام Result Type للتحكم الأفضل</h5>
        <p>Result type بيساعد في التمييز بين Success وFailure states</p>
      </div>

      <div class="code-container">
        <pre><code class="language-swift">
// Custom Error Types
enum APIError: LocalizedError {
    case networkError
    case invalidResponse
    case serverError(Int)
    case decodingError
    case unauthorized
    case notFound
    
    var errorDescription: String? {
        switch self {
        case .networkError:
            return "Network connection failed"
        case .invalidResponse:
            return "Invalid server response"
        case .serverError(let code):
            return "Server error with code: \(code)"
        case .decodingError:
            return "Failed to decode response"
        case .unauthorized:
            return "Unauthorized access"
        case .notFound:
            return "Resource not found"
        }
    }
    
    var recoverySuggestion: String? {
        switch self {
        case .networkError:
            return "Check your internet connection and try again"
        case .unauthorized:
            return "Please log in again"
        case .serverError:
            return "Try again later or contact support"
        default:
            return "Please try again"
        }
    }
}

@MainActor
class ResultBasedViewModel: ObservableObject {
    @Published var loadingState: LoadingState<[User]> = .idle
    
    enum LoadingState<T> {
        case idle
        case loading
        case success(T)
        case failure(Error)
    }
    
    func fetchUsers() async {
        loadingState = .loading
        
        let result = await APIService.shared.fetchUsersResult()
        
        switch result {
        case .success(let users):
            loadingState = .success(users)
        case .failure(let error):
            loadingState = .failure(error)
        }
    }
    
    func retryFetch() async {
        await fetchUsers()
    }
}

struct ResultBasedErrorView: View {
    @StateObject private var viewModel = ResultBasedViewModel()
    
    var body: some View {
        NavigationView {
            Group {
                switch viewModel.loadingState {
                case .idle:
                    Text("Tap to load users")
                        .foregroundColor(.secondary)
                    
                case .loading:
                    VStack {
                        ProgressView()
                        Text("Loading users...")
                            .foregroundColor(.secondary)
                    }
                    
                case .success(let users):
                    List(users) { user in
                        UserRowView(user: user)
                    }
                    .refreshable {
                        await viewModel.fetchUsers()
                    }
                    
                case .failure(let error):
                    ErrorStateView(
                        error: error,
                        onRetry: {
                            Task {
                                await viewModel.retryFetch()
                            }
                        }
                    )
                }
            }
            .navigationTitle("Users")
            .task {
                await viewModel.fetchUsers()
            }
        }
    }
}

struct ErrorStateView: View {
    let error: Error
    let onRetry: () -> Void
    
    var body: some View {
        VStack(spacing: 16) {
            Image(systemName: "exclamationmark.triangle.fill")
                .font(.largeTitle)
                .foregroundColor(.red)
            
            Text("Something went wrong")
                .font(.headline)
            
            Text(error.localizedDescription)
                .font(.body)
                .multilineTextAlignment(.center)
                .foregroundColor(.secondary)
            
            if let apiError = error as? APIError,
               let suggestion = apiError.recoverySuggestion {
                Text(suggestion)
                    .font(.caption)
                    .multilineTextAlignment(.center)
                    .foregroundColor(.secondary)
            }
            
            Button("Try Again", action: onRetry)
                .buttonStyle(.borderedProminent)
        }
        .padding()
    }
}
</code></pre>
      </div>

      <h2 class="section-title">🔄 Multiple Async Operations Error Handling</h2>

      <div class="warning-box">
        <h5>التعامل مع عدة عمليات async في نفس الوقت</h5>
        <p>إدارة الأخطاء عند تشغيل multiple async operations</p>
      </div>

      <div class="code-container">
        <pre><code class="language-swift">
@MainActor
class MultipleOperationsViewModel: ObservableObject {
    @Published var users: [User] = []
    @Published var posts: [Post] = []
    @Published var comments: [Comment] = []
    @Published var loadingStates = LoadingStates()
    @Published var errors: [OperationError] = []
    
    struct LoadingStates {
        var users = false
        var posts = false
        var comments = false
        
        var isAnyLoading: Bool {
            users || posts || comments
        }
    }
    
    struct OperationError: Identifiable {
        let id = UUID()
        let operation: String
        let error: Error
        let timestamp = Date()
    }
    
    func loadAllData() async {
        // Clear previous errors
        errors.removeAll()
        
        // Start all operations concurrently
        async let usersResult = loadUsers()
        async let postsResult = loadPosts()
        async let commentsResult = loadComments()
        
        // Wait for all results
        let _ = await (usersResult, postsResult, commentsResult)
    }
    
    private func loadUsers() async {
        loadingStates.users = true
        
        do {
            let fetchedUsers = try await APIService.shared.fetchUsers()
            users = fetchedUsers
        } catch {
            errors.append(OperationError(operation: "Loading Users", error: error))
        }
        
        loadingStates.users = false
    }
    
    private func loadPosts() async {
        loadingStates.posts = true
        
        do {
            let fetchedPosts = try await APIService.shared.fetchPosts()
            posts = fetchedPosts
        } catch {
            errors.append(OperationError(operation: "Loading Posts", error: error))
        }
        
        loadingStates.posts = false
    }
    
    private func loadComments() async {
        loadingStates.comments = true
        
        do {
            let fetchedComments = try await APIService.shared.fetchComments()
            comments = fetchedComments
        } catch {
            errors.append(OperationError(operation: "Loading Comments", error: error))
        }
        
        loadingStates.comments = false
    }
    
    func retryFailedOperations() async {
        let failedOperations = errors.map { $0.operation }
        errors.removeAll()
        
        await withTaskGroup(of: Void.self) { group in
            if failedOperations.contains("Loading Users") {
                group.addTask { await self.loadUsers() }
            }
            if failedOperations.contains("Loading Posts") {
                group.addTask { await self.loadPosts() }
            }
            if failedOperations.contains("Loading Comments") {
                group.addTask { await self.loadComments() }
            }
        }
    }
}

struct MultipleOperationsView: View {
    @StateObject private var viewModel = MultipleOperationsViewModel()
    
    var body: some View {
        NavigationView {
            VStack {
                // Error Summary
                if !viewModel.errors.isEmpty {
                    ErrorSummaryView(
                        errors: viewModel.errors,
                        onRetry: {
                            Task {
                                await viewModel.retryFailedOperations()
                            }
                        }
                    )
                }
                
                // Loading Indicator
                if viewModel.loadingStates.isAnyLoading {
                    LoadingProgressView(loadingStates: viewModel.loadingStates)
                }
                
                // Content Sections
                List {
                    if !viewModel.users.isEmpty {
                        Section("Users") {
                            ForEach(viewModel.users) { user in
                                UserRowView(user: user)
                            }
                        }
                    }
                    
                    if !viewModel.posts.isEmpty {
                        Section("Posts") {
                            ForEach(viewModel.posts) { post in
                                PostRowView(post: post)
                            }
                        }
                    }
                    
                    if !viewModel.comments.isEmpty {
                        Section("Comments") {
                            ForEach(viewModel.comments) { comment in
                                CommentRowView(comment: comment)
                            }
                        }
                    }
                }
            }
            .navigationTitle("Dashboard")
            .task {
                await viewModel.loadAllData()
            }
            .refreshable {
                await viewModel.loadAllData()
            }
        }
    }
}

struct ErrorSummaryView: View {
    let errors: [MultipleOperationsViewModel.OperationError]
    let onRetry: () -> Void
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                Image(systemName: "exclamationmark.triangle.fill")
                    .foregroundColor(.red)
                Text("\(errors.count) operations failed")
                    .font(.headline)
                Spacer()
                Button("Retry Failed", action: onRetry)
                    .buttonStyle(.borderedProminent)
                    .controlSize(.small)
            }
            
            ForEach(errors) { error in
                HStack {
                    Text("• \(error.operation)")
                        .font(.caption)
                    Spacer()
                    Text(error.error.localizedDescription)
                        .font(.caption2)
                        .foregroundColor(.secondary)
                        .lineLimit(1)
                }
            }
        }
        .padding()
        .background(Color.red.opacity(0.1))
        .cornerRadius(8)
        .padding(.horizontal)
    }
}

struct LoadingProgressView: View {
    let loadingStates: MultipleOperationsViewModel.LoadingStates
    
    var body: some View {
        VStack {
            Text("Loading data...")
                .font(.headline)
            
            HStack {
                LoadingItem(name: "Users", isLoading: loadingStates.users)
                LoadingItem(name: "Posts", isLoading: loadingStates.posts)
                LoadingItem(name: "Comments", isLoading: loadingStates.comments)
            }
        }
        .padding()
    }
}

struct LoadingItem: View {
    let name: String
    let isLoading: Bool
    
    var body: some View {
        VStack {
            if isLoading {
                ProgressView()
                    .scaleEffect(0.7)
            } else {
                Image(systemName: "checkmark.circle.fill")
                    .foregroundColor(.green)
            }
            Text(name)
                .font(.caption)
        }
        .frame(maxWidth: .infinity)
    }
}
</code></pre>
      </div>

      <h2 class="section-title">🎛️ Error Recovery Patterns</h2>

      <div class="success-box">
        <h5>Automatic Retry with Exponential Backoff</h5>
        <p>إعادة المحاولة التلقائية مع زيادة تدريجية في وقت الانتظار</p>
      </div>

      <div class="code-container">
        <pre><code class="language-swift">
actor RetryService {
    private let maxRetries: Int
    private let baseDelay: TimeInterval
    
    init(maxRetries: Int = 3, baseDelay: TimeInterval = 1.0) {
        self.maxRetries = maxRetries
        self.baseDelay = baseDelay
    }
    
    func executeWithRetry<T>(
        operation: @escaping () async throws -> T
    ) async throws -> T {
        var lastError: Error?
        
        for attempt in 0..<maxRetries {
            do {
                return try await operation()
            } catch {
                lastError = error
                
                // Don't retry on final attempt
                guard attempt < maxRetries - 1 else { break }
                
                // Don't retry certain errors
                if let apiError = error as? APIError {
                    switch apiError {
                    case .unauthorized, .notFound:
                        throw error // Don't retry these
                    default:
                        break // Retry other errors
                    }
                }
                
                // Exponential backoff: 1s, 2s, 4s, etc.
                let delay = baseDelay * pow(2.0, Double(attempt))
                try await Task.sleep(nanoseconds: UInt64(delay * 1_000_000_000))
            }
        }
        
        throw lastError ?? APIError.networkError
    }
}

@MainActor
class RetryViewModel: ObservableObject {
    @Published var data: [Item] = []
    @Published var isLoading = false
    @Published var error: Error?
    @Published var retryCount = 0
    
    private let retryService = RetryService()
    
    func loadData() async {
        isLoading = true
        error = nil
        retryCount = 0
        
        do {
            let result = try await retryService.executeWithRetry {
                // This closure will be retried automatically
                try await APIService.shared.fetchData()
            }
            
            data = result
            
        } catch {
            self.error = error
            print("Failed after retries: \(error)")
        }
        
        isLoading = false
    }
    
    func manualRetry() async {
        retryCount += 1
        await loadData()
    }
}

struct RetryPatternView: View {
    @StateObject private var viewModel = RetryViewModel()
    
    var body: some View {
        NavigationView {
            VStack {
                if viewModel.isLoading {
                    VStack {
                        ProgressView()
                        Text("Loading data...")
                        if viewModel.retryCount > 0 {
                            Text("Retry attempt: \(viewModel.retryCount)")
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }
                    }
                } else if let error = viewModel.error {
                    ErrorRetryView(
                        error: error,
                        retryCount: viewModel.retryCount,
                        onRetry: {
                            Task {
                                await viewModel.manualRetry()
                            }
                        }
                    )
                } else {
                    List(viewModel.data) { item in
                        ItemRowView(item: item)
                    }
                }
            }
            .navigationTitle("Retry Pattern")
            .task {
                await viewModel.loadData()
            }
        }
    }
}

struct ErrorRetryView: View {
    let error: Error
    let retryCount: Int
    let onRetry: () -> Void
    
    var body: some View {
        VStack(spacing: 16) {
            Image(systemName: "wifi.exclamationmark")
                .font(.largeTitle)
                .foregroundColor(.red)
            
            Text("Connection Failed")
                .font(.headline)
            
            Text(error.localizedDescription)
                .multilineTextAlignment(.center)
                .foregroundColor(.secondary)
            
            if retryCount > 0 {
                Text("Attempted \(retryCount) time\(retryCount == 1 ? "" : "s")")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            
            Button("Try Again", action: onRetry)
                .buttonStyle(.borderedProminent)
        }
        .padding()
    }
}
</code></pre>
      </div>

      <h2 class="section-title">🎯 Best Practices</h2>

      <div class="highlight-box">
        <h4>أفضل الممارسات للـ Error Handling:</h4>
        <ol>
          <li><strong>Custom Error Types:</strong> اعمل error types واضحة ومفيدة</li>
          <li><strong>User-friendly Messages:</strong> اعرض رسائل واضحة للمستخدم</li>
          <li><strong>Retry Logic:</strong> وفر إمكانية إعادة المحاولة</li>
          <li><strong>Loading States:</strong> وضح للمستخدم أن العملية جارية</li>
          <li><strong>Error Recovery:</strong> اعطي suggestions لحل المشكلة</li>
          <li><strong>Logging:</strong> سجل الأخطاء للـ debugging</li>
        </ol>
      </div>

      <h2 class="section-title">📊 الخلاصة</h2>

      <div class="concept-box">
        <p>
          <strong>Async Error Handling في SwiftUI:</strong>
        </p>
        <ul>
          <li><strong>try-catch blocks:</strong> للـ basic error handling</li>
          <li><strong>Result types:</strong> للتحكم الأفضل في States</li>
          <li><strong>Custom error types:</strong> لتقديم معلومات أفضل</li>
          <li><strong>Retry patterns:</strong> للتعافي التلقائي من الأخطاء</li>
          <li><strong>Multiple operations:</strong> إدارة أخطاء العمليات المتعددة</li>
          <li><strong>User experience:</strong> عرض الأخطاء بطريقة مفيدة</li>
        </ul>
      </div>

      <div class="mt-4">
        <a href="../SwiftUI_Interview_Questions.html" class="back-btn">
          ← العودة للأسئلة الرئيسية
        </a>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/autoloader/prism-autoloader.min.js"></script>
  </body>
</html>