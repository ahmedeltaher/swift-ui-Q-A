<!DOCTYPE html>
<html lang="ar" dir="rtl">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>How does SwiftUI achieve declarative UI compared to UIKit's imperative UI?</title>
  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <!-- Custom CSS -->
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #121212;
      color: #e0e0e0;
      padding: 20px;
    }

    .card {
      margin-bottom: 25px;
      border-radius: 15px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
      overflow: hidden;
      border: none;
    }

    .advanced-level {
      background: linear-gradient(135deg, #7ba69f 0%, #9ac2bb 100%);
    }

    .card-header {
      color: white;
      font-weight: bold;
      border-radius: 0 !important;
      padding: 20px;
      background: rgba(0, 0, 0, 0.1);
      border-bottom: 1px solid rgba(255, 255, 255, 0.2);
      text-align: center;
    }

    .card-body {
      padding: 25px;
      line-height: 1.8;
      color: white;
      text-align: left;
    }

    .main-title {
      background: linear-gradient(135deg, #7ba69f 0%, #9ac2bb 100%);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      text-align: center;
      margin-bottom: 30px;
      font-size: 2.5rem;
      font-weight: bold;
      filter: brightness(1.2);
      text-shadow: 0 0 15px rgba(123, 166, 159, 0.5);
    }

    .content-container {
      max-width: 900px;
      margin: 0 auto;
    }

    .answer-section {
      background-color: rgba(255, 255, 255, 0.1);
      border-radius: 15px;
      padding: 25px;
      margin-bottom: 25px;
      direction: ltr;
      text-align: left;
    }

    .explanation-section {
      background-color: rgba(255, 255, 255, 0.05);
      border-radius: 15px;
      padding: 25px;
      margin-bottom: 25px;
    }

    .answer-title,
    .explanation-title {
      font-weight: bold;
      margin-bottom: 15px;
      color: #e0e0e0;
    }

    .code-block {
      background-color: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      padding: 15px;
      margin: 15px 0;
      overflow-x: auto;
    }

    pre {
      color: #e0e0e0;
      margin: 0;
    }

    .back-button {
      background: linear-gradient(135deg, #7ba69f 0%, #9ac2bb 100%);
      color: white;
      border: none;
      border-radius: 8px;
      padding: 10px 20px;
      margin-bottom: 20px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-decoration: none;
      display: inline-block;
    }

    .back-button:hover {
      transform: translateY(-3px);
      box-shadow: 0 4px 15px rgba(123, 166, 159, 0.5);
      color: white;
      text-decoration: none;
    }

    footer {
      text-align: center;
      margin-top: 40px;
      color: #a0a0a0;
      padding: 20px;
    }

    .highlight {
      color: #9ac2bb;
      font-weight: bold;
    }

    table {
      width: 100%;
      margin: 20px 0;
      border-collapse: collapse;
    }

    th,
    td {
      padding: 12px 15px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    th {
      background-color: rgba(0, 0, 0, 0.2);
    }

    tr:nth-child(even) {
      background-color: rgba(255, 255, 255, 0.03);
    }

    .comparison-box {
      background-color: rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      padding: 15px;
      margin: 10px 0;
      border-left: 4px solid #9ac2bb;
    }

    .imperative-box {
      border-left-color: #ff6b6b;
    }

    .declarative-box {
      border-left-color: #51cf66;
    }
  </style>
</head>

<body>
  <div class="content-container">
    <a href="../SwiftUI_Interview_Questions.html" class="back-button">← العودة للأسئلة</a>

    <h1 class="main-title">How does SwiftUI achieve declarative UI compared to UIKit's imperative UI?</h1>

    <div class="card advanced-level">
      <div class="card-header">
        <h3 class="mb-0">Answer in English</h3>
      </div>
      <div class="card-body">
        <div class="answer-section">
          <h4>Declarative vs Imperative Programming Paradigms:</h4>
          
          <div class="comparison-box imperative-box">
            <h5>Imperative UI (UIKit):</h5>
            <p><strong>"How to do it"</strong> - You explicitly tell the system step-by-step what to do and when to do it.</p>
            <ul>
              <li>Manual view creation and configuration</li>
              <li>Explicit state management and UI updates</li>
              <li>Procedural approach with detailed instructions</li>
            </ul>
          </div>

          <div class="comparison-box declarative-box">
            <h5>Declarative UI (SwiftUI):</h5>
            <p><strong>"What you want"</strong> - You describe the desired end state, and the system figures out how to achieve it.</p>
            <ul>
              <li>Describe the UI structure and behavior</li>
              <li>Automatic state synchronization</li>
              <li>Functional approach with state-driven updates</li>
            </ul>
          </div>

          <h4>Code Comparison:</h4>

          <h5>UIKit (Imperative) Example:</h5>
          <div class="code-block">
            <pre><code>class ViewController: UIViewController {
    @IBOutlet weak var label: UILabel!
    @IBOutlet weak var button: UIButton!
    
    var counter = 0 {
        didSet {
            // Manually update UI when state changes
            updateUI()
        }
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        setupUI()
        updateUI()
    }
    
    func setupUI() {
        // Manual view configuration
        button.setTitle("Increment", for: .normal)
        button.addTarget(self, action: #selector(incrementTapped), for: .touchUpInside)
    }
    
    func updateUI() {
        // Manually sync state with UI
        label.text = "Count: \(counter)"
        button.isEnabled = counter < 10
        
        if counter > 5 {
            label.textColor = .red
        } else {
            label.textColor = .black
        }
    }
    
    @objc func incrementTapped() {
        counter += 1
    }
}</code></pre>
          </div>

          <h5>SwiftUI (Declarative) Example:</h5>
          <div class="code-block">
            <pre><code>struct ContentView: View {
    @State private var counter = 0
    
    var body: some View {
        VStack {
            // Describe what you want, not how to build it
            Text("Count: \(counter)")
                .foregroundColor(counter > 5 ? .red : .black)
            
            Button("Increment") {
                counter += 1
            }
            .disabled(counter >= 10)
        }
    }
}

// UI automatically updates when counter changes
// No manual updateUI() calls needed</code></pre>
          </div>

          <h4>Key Mechanisms Behind SwiftUI's Declarative Nature:</h4>

          <table>
            <tr>
              <th>Mechanism</th>
              <th>Purpose</th>
              <th>How it Works</th>
            </tr>
            <tr>
              <td>Property Wrappers</td>
              <td>State management</td>
              <td>@State, @Binding automatically trigger UI updates</td>
            </tr>
            <tr>
              <td>View Protocol</td>
              <td>UI description</td>
              <td>body property describes desired UI state</td>
            </tr>
            <tr>
              <td>Diffing Algorithm</td>
              <td>Efficient updates</td>
              <td>Compares view trees and updates only what changed</td>
            </tr>
            <tr>
              <td>Result Builders</td>
              <td>Declarative syntax</td>
              <td>@ViewBuilder enables natural view composition</td>
            </tr>
          </table>

          <h4>Benefits of Declarative Approach:</h4>
          <ul>
            <li><strong>Reduced Boilerplate:</strong> Less code to write and maintain</li>
            <li><strong>Automatic Synchronization:</strong> UI stays in sync with state</li>
            <li><strong>Predictable Behavior:</strong> UI is a function of state</li>
            <li><strong>Easier Testing:</strong> Pure functions are easier to test</li>
            <li><strong>Better Composition:</strong> Views compose naturally</li>
          </ul>

          <h4>State-Driven Architecture:</h4>
          <div class="code-block">
            <pre><code>// In SwiftUI, UI = f(State)
struct UserProfile: View {
    @StateObject private var user = UserStore()
    
    var body: some View {
        // UI automatically reflects user state
        VStack {
            if user.isLoading {
                ProgressView()
            } else if let profile = user.profile {
                AsyncImage(url: profile.avatarURL)
                Text(profile.name)
                Text(profile.email)
            } else {
                Text("Failed to load profile")
                Button("Retry") {
                    user.loadProfile()
                }
            }
        }
    }
}</code></pre>
          </div>

          <h4>How SwiftUI Achieves This:</h4>
          <ol>
            <li><strong>Reactive Programming:</strong> Property wrappers observe changes</li>
            <li><strong>Virtual View Tree:</strong> Lightweight view descriptions</li>
            <li><strong>Automatic Reconciliation:</strong> Framework handles UI updates</li>
            <li><strong>Functional Composition:</strong> Views compose like functions</li>
          </ol>
        </div>
      </div>
    </div>

    <div class="explanation-section">
      <h3 class="explanation-title">الشرح بالعربي</h3>
      
      <h4>الفرق بين Declarative و Imperative:</h4>
      
      <div class="comparison-box imperative-box">
        <h5>UIKit (Imperative - إجرائي):</h5>
        <p><span class="highlight">"ازاي تعمله"</span> - إنت بتقول للنظام خطوة بخطوة يعمل إيه ومتى.</p>
        <ul>
          <li>إنشاء وتكوين الـ views يدوياً</li>
          <li>تحديث الـ UI بإيدك كل مرة</li>
          <li>مراقبة التغييرات وإدارتها بنفسك</li>
        </ul>
      </div>

      <div class="comparison-box declarative-box">
        <h5>SwiftUI (Declarative - تصريحي):</h5>
        <p><span class="highlight">"إيه اللي عايزه"</span> - إنت بتوصف الشكل النهائي والنظام يشوف ازاي يوصله.</p>
        <ul>
          <li>وصف شكل الـ UI بس</li>
          <li>تحديث تلقائي لما الـ state يتغير</li>
          <li>النظام يهتم بالتفاصيل</li>
        </ul>
      </div>
      
      <h4>مثال توضيحي:</h4>
      
      <p><strong>في UIKit:</strong></p>
      <div class="code-block">
        <pre><code>// لازم تعمل كل حاجة بإيدك
var counter = 0 {
    didSet {
        label.text = "العدد: \(counter)"
        button.isEnabled = counter < 10
        if counter > 5 {
            label.textColor = .red
        }
    }
}</code></pre>
      </div>
      
      <p><strong>في SwiftUI:</strong></p>
      <div class="code-block">
        <pre><code>// بس وصف الشكل المطلوب
@State var counter = 0

var body: some View {
    VStack {
        Text("العدد: \(counter)")
            .foregroundColor(counter > 5 ? .red : .black)
        
        Button("زيادة") {
            counter += 1
        }
        .disabled(counter >= 10)
    }
}</code></pre>
      </div>
      
      <h4>ازاي SwiftUI بيحقق ده:</h4>
      <ul>
        <li><strong>Property Wrappers:</strong> زي @State بيراقب التغييرات تلقائياً</li>
        <li><strong>View Protocol:</strong> بيوصف شكل الـ UI</li>
        <li><strong>Diffing Algorithm:</strong> بيحدث بس اللي اتغير</li>
        <li><strong>Reactive Programming:</strong> الـ UI بيتفاعل مع التغييرات لوحده</li>
      </ul>
      
      <h4>مزايا الـ Declarative Approach:</h4>
      <ul>
        <li><strong>كود أقل:</strong> مش محتاج تكتب كل التفاصيل</li>
        <li><strong>أقل أخطاء:</strong> النظام بيهتم بالتزامن</li>
        <li><strong>سهولة الفهم:</strong> الكود بيوضح النتيجة المطلوبة</li>
        <li><strong>سهولة الاختبار:</strong> functions نظيفة وواضحة</li>
      </ul>
      
      <h4>القاعدة الذهبية:</h4>
      <p><span class="highlight">UI = Function(State)</span></p>
      <p>يعني الـ UI هو نتيجة الـ State الحالي. لما الـ State يتغير، الـ UI يتحدث تلقائياً!</p>
      
      <p><span class="highlight">خلاصة:</span> SwiftUI خلاك تركز على "إيه اللي عايزه" مش "ازاي تعمله"، ودا بيوفر وقت ومجهود كبير!</p>
    </div>

    <a href="../SwiftUI_Interview_Questions.html" class="back-button">← العودة للأسئلة</a>
  </div>

  <footer>
    صفحة إجابة سؤال SwiftUI — الشرح بالعربي والإنجليزي
  </footer>
</body>

</html>